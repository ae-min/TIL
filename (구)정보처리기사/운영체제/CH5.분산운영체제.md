# S1. 컴퓨터시스템과 운영체제
## 1. 컴퓨터시스템의 구조
### SISD (Single Instruction Single Data)
- 단일처리기 컴퓨터로서, 한 번에 한 명령만을 처리 (단일처리기 : 중앙처리장치CPU를 의미, 프로세서라고도 함)
- 1명의 사용자가 1개의 CPU를 사용
- 개인용컴퓨터 수준
- 다수의 기계어 명령어들이 동시에 서로 다른 단계에서 수행할 수 있게 하는 파이프라인 기법에 응용가능
### SIMD (Single Instruction Multiple Data)
- 다중처리기 컴퓨터로서, 한번에 한 명령어만을 처리
- 1명의 사용자가 여러개의 CPU 사용
- 슈퍼컴퓨터, 과학기술용컴퓨터 수준
- 배열처리 기법에 응용 가능
### MISD (Multiple Instruction Single Data)
- 단일처리기 컴퓨터로서, 한번에 여러개의 명령어를 처리
- 여러명의 사용자가 하나의 CPU 사용
### MIMD (Multiple Instruction Multiple Data)
- 다중처리기 컴퓨터로서, 한번에 여러개의 명령어를 처리
- 여러명의 사용자가 여러개의 CPU를 사용
- 일반적으로 다중처리기 또는 다중컴퓨터라고 함

## 2. MIMD
## 2.1 다중처리기 (Multi-Processor)
- 여러개의 CPU가 하나의 메모리를 공유하는 형태
- CPU끼리 결합이 강함(강결합)
- 병렬처리시스템에 적합
- 전송지연이 짧고, 데이터처리율 높음
- 프로세스 간 통신은 공유 메모리를 통해 이루어짐
- 공유 메모리를 차지하려는 프로세스 간의 경쟁 발생
- 기억장소가 한개 이므로 운영체제도 종속적으로 사용됨
- 모든 CPU는 하나의 운영체제에서 통제되는 대칭적인 구조

## 2.2 다중컴퓨터 (Multi-Computer)
- 여러개의 CPU가 자신만의 독립적인 메모리를 사용하는 형태
- CPU끼리 결합력이 약함(약결합)
- 분산처리시스템에 적합
- 전송지연이 길고, 데이터처리율이 낮음
- 프로세스 간의 통신은 통신망에 메시지(소켓)전달로 통신할 수 있음
- 구성요소(컴퓨터, 주변장치 등)의 추가 또는 삭제가 용이
- 기억장소가 CPU와 독립적으로 사용되므로, 운영체제도 독립적으로 사용됨
- 각 시스템은 자신만의 운영체제를 갖는 분리 수행 구조

## 3. 다중처리기와 운영체제 구성
## 3.1 주/종(Master/Slave) 프로세서 구조
- 하나의 컴퓨터 시스템에 두 개의 프로세서(처리기,CPU)가 있는 경우, 입출력과 연산을 각각 독립적으로 수행하지 않고
- 주 프로세서는 입출력과 연산을 담당
- 종 프로세서는 연산의 일부를 담당하게 됨
- 주 프로세서가 중단되면 어쩔 수 없이 시스템이 멈추지만, 종 프로세서는 중단되도 컴퓨터 시스템은 계속 동작가능하기 때문
- 종 프로세서에서 입출력 발생 시, 주 프로세서에게 서비스를 요청함
- 프로세서가 비대칭 구조

      [주 프로세서]
      - 입출력과 연산 담당
      - 주 프로세서만이 운영체제 수행

      [종 프로세서]
      - 연산의 일부 담당
      - 종 프로세서는 사용자 프로그램만을 수행


## 3.2 분리수행(개별관리자, Separate-Execution)
- 각 프로세서가 독립적인 운영체제를 가짐
- 각 프로세서에서 발생하는 인터럽트도 해당 프로세서에서 독립적으로 수행
- 각 프로세서는 자신만의 파일과 입출력장치를 제어
- 프로세서가 독립적이므로, 프로세서에 따라 유휴상태(CPU가 쉬는 상태)이거나 매우 바쁠 수 있음
- 한 프로세서의 고장으로 전 시스템이 멈추지는 않으므로 신뢰성이 높음

## 3.3 대칭적구조(Symmetric)
- 여러 프로세서가 하나의 운영체제에서 동시 운영됨
- 여러개의 프로세서가 동시 수행 가능
- 가장 강력한 시스템이지만, 매우 복잡한 구조
- 하나의 프로세서가 중단되면 능력이 다소 떨어지지만, 중단없이 계속 가동됨
- 프로세서의 수를 늘린다고 해도 시스템효율은 향상되지 않음

---
# S2. 분산 운영체제 시스템
## 1. 분산 운영체제 정의
- 각 호스트에 고유한 운영체제가 있는 것이 아니라, 전체 네트워크에 공통적으로 단일 운영체제가 실행되는 시스템
- 원격에 있는 자원을 마치 지역 자원인 것처럼 쉽게 접근하여 사용 가능

## 1.1 분산 운영체제 목적
    1) 자원공유의 증대성 : 각 시스템이 통신망을 통해 연결되어 있으므로, 유용한 자원을 공유하여 사용 가능
    2) 연산속도의 향상 : 하나의 일을 여러시스템이 분산하여 처리하기 때문에 연산속도가 향상됨
    3) 신뢰성 향상 : 하나의 시스템에 오류가 발생하더라도, 다른 시스템은 계속 작업 수행 가능
    4) 컴퓨터 통신 : 지리적으로 떨어진 시스템에 통신망을 두어 정보 교환 가능
## 1.2 분산 운영체제 장점
- CPU 처리능력의 한계 극복가능
- 처리속도가 낮은 여러개의 CPU를 연결하여 처리속도를 향상시킬 수 있기 때문에 경제적임
- 반응시간이 빠르면 연산능력, 처리량, 신뢰성, 가용성이 모두 향상됨
- 특정 시스템의 병목현상을 제거하기위해 필요한 자원을 추가할 수 있으므로 확장성이 좋음
- 부하를 균등배분할 수 있어서 처리효율이 향상됨
- 다수의 사용자가 데이터를 공유할 수 있으며, 통신이 용이함
 
## 1.3 분산 운영체제 단점
- 여러개의 컴퓨터시스템이 연결되어 있으므로, 보안이 매우 취약함
- 여러개의 컴퓨터를 하나의 컴퓨터처럼 운영해야하므로, 소프트웨어 개발이 매우 어려움
- 적응성이 하나의 CPU를 사용할때보다는 떨어짐
- 에러 발생 시 원인 파악이 어려움

## 1.4 분산 운영체제 결함
    1) 링크결함 : 두개의 사이트(컴퓨터,노드,교환기)간에 연결이 잘못되어 발생하는 결함
    2) 사이트결함 : 사이트 자체에서 발생할 수 있는 결함
    3) 메시지분실 : 통신회선을 통해 해당 사이트로 메시지가 전달되는 과정에서, 
                   시간지연이나 다른 이유로 메시지를 잃어버리는 결함

## 2. 분산 운영체제의 위상
<img width="320" src="https://user-images.githubusercontent.com/29009929/154245205-9ef7c23c-44a6-400c-bc94-0d7910acdf49.png">
<img width="320" src="https://user-images.githubusercontent.com/29009929/154245480-905e8112-440d-41da-bb31-75c68b663a18.png">

## 2.1 성형(Star)
- 각 노드가 Point-to-Point 형태로 중앙컴퓨터에 연결되고, 중앙컴퓨터를 경유함
- 제어가 집중되고 모든 동작이 중앙컴퓨터에 의해 감시됨
- 중앙컴퓨터에 과부화가 걸리면, 성능이 현저히 저하됨
- 중앙컴퓨터에 장애 발생 시, 전체 시스템이 마비됨
- 한 노드의 고장은 다른 노드에 영향을 주지 않음
- 터미널(노드,사이트)의 증가에 따라 통신회선의 수도 증가함
- 최소 두개의 노드만 사용할 수 있으므로 통신비용이 저렴함

## 2.2 환형(Ring)
- 각 사이트는 정확히 다른 두 사이트와 물리적으로 연결되어있음
- 정보전달방향은 단방향 또는 양방향일 수 있음
- 기본비용은 사이트의 수에 비례
- 메시지가 링을 순환할 경우, 통신비용은 증가함
- 근거리 네트워크 구조로, 가장 많이 사용됨

## 2.3 다중접근버스연결(Multi-access Bus Connection)
- 한 사이트의 고장은 나머지 사이트들 간의 통신에 아무런 영향을 주지 않음
- 한 시점에 단지 하나의 전송만이 가능
- 처리기나 기타장치의 증설 절차가 복잡하지 않음
- 버스의 사용을 위한 경쟁상태가 발생하여, 시스템 성능의 심각한 저해를 가져올 수 있음
- 버스에 이상이 생기면, 전체 시스템이 마비됨
- 시스템의 전체 통신량이 전송률에 의한 제한을 받음
- 시스템이 바빠지면 버스 사용은 성능효율을 저하시킴
- 통신회선이 1개이므로, 물리적 구조가 간단

## 2.4 완전연결(Fully Connected)
- 네트워크의 각 사이트는 시스템 내의 다른 모든 사이트와 직접연결된 구조
- 기본비용이 매우 높음. 대신에 통신비용은 낮음
- 사이트간의 메시지는 매우 빠르게 전달됨
- 하나의 링크가 고장나도, 다른 링크를 이용할 수 있으므로 신뢰성 높음

## 2.5 부분연결(Partially Connected)
- 시스템 내의 사이트 간에만 부분적으로 연결된 구조
- 기본비용이 완전연결보다는 저렴함
- 메시지 전달이 중간 사이트를 경유할 수 있으므로, 늦어질 수 있음
- 완전연결에 비해 신뢰성이 높지 않음

## 2.6 계층연결(Hierarchy Connected)
- 사이트들은 트리형태로 구성됨
- 루트사이트와 서브사이트 존재
- 루트사이트를 제외한 다른사이트는 하나의 부모사이트와 여러개의 자식사이트를 가짐
- 기본비용이 부분연결보다 저렴함
- 마지막사이트(단 노드)를 제외한 사이트의 고장은 자식사이트의 중단을 초래함

---
## 3. 분산 운영체제의 설계 쟁점
- 투명성/융통성/신뢰성/결함허용/성능/확장성

## 3.1 투명성(Transparency)
      위치투명성 : 사용자가 원하는 자원들이 다른 원격지에 위치하더라도, 그 위치에 관계없이 사용 가능
      이주투명성 : 자원을 이동하여도 사용자는 자원의 이름이나 위치를 고려하지 않아도됨
      복제투명성 : 사용자에게 통보없이 파일들과 자원들의 부가적인 복사를 자유롭게 가능
      병행투명성 : 사용자들이 자원을 자동 공유 가능
      병렬투명성 : 몇개의 처리기가 사용되는지 알 필요 

## 4. 클라이언트/서버 시스템
## 4.1 클라이언트/서버 시스템
- 서버는 다양한 시스템기능과 자원을 제공하고, 클라이언트는 다양한 서비스를 제공받을 수 있는 시스템

### 클라이언트/서버 시스템 이전의 '중앙집중시스템'
- 호스트컴퓨터와 더미단말기로 연결된 네트워크 구조
- 더미단말기는 메모리나 처리능력이 없이 전적으로 호스트컴퓨터에 의존하기 때문에, 호스트가 다운되면 모든 작업은 중단됨

## 4.3 NFS (Network File System, 네트워크파일시스템)
- 씬 마이크로시스템즈가 개발한 분산컴퓨터시스템 환경
- 네트워크를 통해 원격파일을 액세스하기 위하여 구현되고 명세화된 파일관리시스템
- 독립퇸 파일시스템을 가진 서로 다른 워크스테이션이 연결된 형태
- 투명성을 통해 시스템간에 이정 수준의 공유를 허용함
- 컴퓨터사용자가 원격지의 컴퓨터에 있는 파일을 마치 자신의 컴퓨터에 있는 것처럼 사용할 수 있는 클라이언트/서버형 응용 프로그램
- 사용자시스템에는 NFS클라이언트가 있어야하고, 원격지컴퓨터에는 NFS서버가 설치되어 있어야함
- TCP/IP를 이용해야하기 때문에 양쪽 모두 TCP/IP 프로토콜이 설치되어 있어야함

## 5. 스레드(Thread)
## 5.1 스레드 : 프로세스 내에서 실행되는 흐름의 단위
<img width="300" src="https://user-images.githubusercontent.com/29009929/154249049-1d7e5d74-9036-4626-9d4d-b9861250a618.png">

### 단일스레드
      - 하나의 프로세스를 수행하는 과정에서, 여러개의 인터럽트 루틴이나 함수를 순서적으로 실행하는 프로세스
      - 하나의 프로세스에는 하나의 스레드

### 다중스레드 (멀티스레드)
      - 하나의 프로세스에 여러개의 스레드가 존재하는 경우 
      
## 5.2 스레드 장점
- 프로세스 안의 스레드들은 레지스터, 스택 공간을 제외한 프로세스의 나머지 공간과 시스템 자원을 공유함
- 단일프로세스를 다수의 스레드로 생성하여, 병행성 증진 가능
- 실행환경 공유함으로써 기억장소의 낭비가 줄어듬
- 프로세스의 생성이나, 문맥교환등의 오버헤드를 줄여 운영체제 성능이 개선됨
- 프로세스 내부에 포함되는 스레드는 공통적으로 접근가능한 기억장치를 통해 효율적으로 통신함
- 스레드를 사용하면 하드웨어, 운영체제의 성능과 응용프로그램의 처리율을 향상시킬 수 있음
- 하나의 프로세스에 여러개의 스레드 존재 가능 (다중스레드)
- 스레드는 동일 프로세스 환경에서 서로 독립적인 다중 수행 가능

## 5.3 스레드 운영의 이점
- 하드웨어의 성능 향상 가능
- 응용프로그램의 처리율 향상 가능
- 응용프로그램의 응답시간 감소 가능
- 프로세스간의 통신속도 향상 가능

## 5.4 스레드 패키지 구현
### 사용자 수준의 스레드
- 사용자 단에서 생성 및 관리되는 스레드
- 커널 레벨 밖에 있는 스레드
- 스레드를 운영하지 않는 운영체제에서 실행할 수 있으므로, 이식성이 뛰어남

      [사용자수준의 스레드 특징]
      - 커널 개입이 적음
      - 런타임시스템 필요
      - 속도 빠름
      - 문맥교환 적음 (문맥교환 : 실행하고 있는 프로그램 혹은 프로세스를 교환하는 것)
      - 독자적 알고리즘 필요
      - 대형시스템에 적당
      - 구현 어려움
      - 커널을 스스로 호출 불가능
      - CPU 사용을 해제하지 못하면 시스템 중단됨

### 커널 수준의 스레드
- 운영체제 시스템 내에서 생성되어 동작하는 스레드로, 커널이 직접 관리
- 커널 레벨에서 생성되는 스레드
- 각 응용프로그램들은 운영체제에 영향을 많이 받게 되므로, 이식성이 낮음

      [커널 수준의 스레드 특징]
      - 커널 개입이 큼
      - 런타임시스템이 필요없고, 커널이 직접함
      - 속도 느림
      - 문맥교환이 많음
      - 독자적 알고리즘 필요 없음
      - 대형시스템에 부적당
      - 구현 쉬움
      - 커널을 스스로 호출
      - CPU 사용을 해제하지 못하면 운영체제가 지원함


