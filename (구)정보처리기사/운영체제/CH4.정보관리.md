# S1. 파일시스템
- 컴퓨터시스템의 편리한 사용을 위해 정보를 저장하고 관리하는 시스템
- 저장장치의 물리적 특성들을 고려하여 논리적으로 저장하고 사용하는 체계
- 컴퓨터에서 사용되는 파일들을 다루는 운영체제의 파일관리체계

## 1. 파일의 구조
## 1.1 순차접근파일 (Sequential Access File)
- **입력되는 데이터의 논리적인 순서에 따라 물리적으로 연속적인 위치에 기록되는 파일 형식**
- 저장매체의 효율이 매우 높음
- 특정 데이터를 검색하는데 비교횟수가 많아지므로 검색(탐색)시간이 느림
- 저장정보를 따로 구성하지 않아도 순서적으로 기록되므로, 공간의 낭비가 없음
- 구현이 쉬움
- 대화식 처리보다 일괄처리에 적합한 구조
- 순차파일은 테이프를 모형화 한 것

## 1.2 직접접근파일 (Direct Access File)
- **데이터 내의 키 필드(Key Field)를 해싱사상함수에 의해 물리적인 주소로 변환하여 데이터를 기록하거나 검색하는 방식의 파일**
- 특정 레코드를 검색하기 위하여 키와 보조기억장치 사이의 물리적인 주소로 변환할 수 있는 사상함수가 필요
- 해싱사상함수를 사용하므로 검색속도가 가장 빠름
- 한번 파일을 개방하면 읽거나 쓰기를 자유롭게 가능
- 어떤 레코드라도 평균 접근 시간내에 접근 가능
- 키를 변환하는 방법에 따라 공간의 낭비를 가져올 수 있음
- 일바적으로 디스크 기억장치에 많이 사용됨

## 1.3 색인순차접근파일 (Indexed Sequential Access File)
- 순차접근과 직접접근 처리가 모두 가능한 방식
- 디스크 기억장치에 많이 사용됨
- 각 레코드는 레코드 키 값에 따라 논리적으로 배열됨
- 시스템은 각 레코드의 실제주소가 저장된 인덱스를 관리
- 순차접근과 직접접근을 병행할 수 있기 때문에 융통성이 뛰어남
- 레코드를 추가 및 삽입하는 경우, 파일 전체를 복사할 필요가 없음
- 삽입, 삭제가 많아지면 파일에 대한 재편성이 이루어져야함
- 실제데이터 처리 외에 인덱스를 처리하는 추가적인 시간이 소모되므로, 파일 처리속도가 느림
- 인덱스를 저장하기 위한 공간과, 오버플로우 처리를 위한 별도의 공간이 필요하므로 기억공간 낭비가 있음
- 파일을 구성하는 블록의 번호는 절대블록번호여야 자신의 파일이 아닌 부분에 접근하는 것을 방지가능

### 색인순차접근파일 구성방법
    - 3단계색인구역(Index Area) : 마스터, 실린더, 트랙
    - 기본데이터구역(Prime Data Area) : 실제 데이터가 기록된 구역
    - 오버플로우구역(Overflow Area) : 실린더 오버플로우, 인디펜던트(독립) 오버플로우

## 2. 파일의 디스크공간 할당과 회수
- 파일과 데이터를 디스크에 물리적으로 저장하고 삭제하는 방법
## 2.1 연속블록할당(Contiguous Block Allocation)
- 물리적으로 연속적인 공간에 저장되고, 저장할 크기를 미리 지정해야하느 방법
- 파일마다 크기가 다르고, 추가 및 삭제가 빈번히 발생할 경우 단편화현상이 많이 발생함
- 따라서, 디스크 활용을 최대화하기 위한 통합, 집약이 필요

### 연속블록할당 특징
    - 파일블록들을 연속적 저장
    - 파일블록들을 분산저장 불가능
    - 파일크기에 해당되는 디스크공간을 미리 지정해야함
    - 단편화 많이 발생
    - 디스크 통합,집약 필요
    - 파일의 크기보다 큰 연속공간이 없을 경우에는 파일 생성 불가능
    - 다중프로그래밍에 사용 어려움
    - 가상기억장치를 응용하여 사용 불가
    - 용적률 줄어듬
    - 액세스 시간 감소
    - 디렉터리 구현 쉬움
    
## 2.2 불연속블록할당(=링크블록할당)
- 디스크공간을 일정한 길이를 갖는 단위(섹터,블록)로 나누어 할당하는 기법
- 분할된 영역은 독립적으로 취급되며, 파일의 데이터들은 분할된 영역에 순차적, 분산적으로 저장할 수 있는 방법
- 연속블록할당의 단점을 보완한 방법
- 분할 저장된 파일의 각 데이터들을 파일open 시에 연결된 정보를 이용해 사용함
- 실제데이터를 저장하는 공간 외에 분할된 정보와 파일의 연결된 데이터 정보를 저장해야하는 영역이 필요하므로 
  부가적인 저장공간이 연속블록할당보다 많이 필요하며, 구현방법도 복잡함
- 섹터단위형 : 디스크섹터단위로 파일의 데이터가 분산저장되며, 각 섹터는 연결리스트 구조로 연결됨, 
              파일의 크기가 커지면 비어있는 섹터를 사용하고, 작아지면 사용하지 않는 섹터를 반납함
- 블록단위형 : 블록체인기법(여러개의 섹터를 묶은 블록을 체인처럼 연결) / 인덱스블록체인기법(인덱스에 블록의 주소를 링크시켜 사용)
               / 블록단위파일사상기법(파일 정보의 해당 블록을 사상시켜 연결하여 사용, MS-DOS, MS-Windows)

### 불연속블록할당 특징
    - 파일블록들을 링크를 연결해 저장
    - 파일블록들을 분산저장 가능
    - 파일 크기에 해당되는 디스크공간 미리 지정하지 않아도됨
    - 단편화 줄이기 가능
    - 디스크 통합, 집약 불필요
    - 파일의 크기보다 큰 연속공간이 없더라도 파일 생성 가능
    - 다중프로그래밍에 유용하게 사용가능
    - 가상기억장치를 응용하여 사용 가능
    - 용적률이 좋아짐
    - 액세스 시간 증가
    - 디렉터리 구현 어려움

## 3. 디렉터리
- 파일시스템 내부에 있는 기능으로, 디스크 내에 존재하는 많은 파일들을 쉽게 사용(저장, 검색, 관리)할 수 있도록 하는 조직화된 기법

## 3.1 1단계(단 단계, 단일단계) 디렉터리
<img width="300" src="https://user-images.githubusercontent.com/29009929/154218168-6c8483bf-f3a4-4bba-83fa-e0c8173ca5f4.png">

- 가장 간단한 구조
- 디렉터리 시스템에 보관된 모든 파일의 정보를 포함해야함
- 파일이 같은 디렉터리에 있어야 하므로, 유일한 파일명으로 작성해야함
- 파일명의 길이를 제한

## 3.2 2단계디렉터리
<img width="300" src="https://user-images.githubusercontent.com/29009929/154218316-f5d42a3c-53e5-48bd-be64-905a991d4afe.png">

- 중앙에 마스터디렉터리가 존재하며, 그 아래에 사용자디렉터리가 있는 구조 (마스터/사용자 디렉터리)
- 다른 사용자의 디렉터리 내의 파일들을 검색할 수 없기 때문에, 다른 사용자와의 파일 공유가 어려움
- 파일명의 길이가 길어 사용하기가 매우 어려움
- 2단계 이상으로 깊어지면 트리구조 디렉터리가 됨

## 3.3 트리구조디렉터리
<img width="300" src="https://user-images.githubusercontent.com/29009929/154218651-e457a85d-4b6e-4d02-8659-1d2801dd706d.png">

- 하나의 루트트렉터리와 여러개의 부(종속)디렉터리로 구성
- 부(종속)디렉터리는 그 하위로 또 다른 디렉터리 구성 가능
- 각 디렉터리의 생성과 파괴가 쉬움
- 동일한 이름의 여러 디렉터리 생성 가능
- UNIX, MS-DOS, MS-Windows 운영체제에서 사용 중

## 3.4 비순환그래프디렉터리
<img width="300" src="https://user-images.githubusercontent.com/29009929/154218876-006d0f6e-6540-486a-8ebf-021ff680a32f.png">

- 사이클을 허용하지 않는 비순환 구조
- 하나의 파일이나 디렉터리를 상위 디렉터리에서 공용 사용 가능
- 하나의 파일을 여러 사용자가 공유하기 때문에 삭제 시 문제점이 많이 발생 (떨어진 포인터가 발생 가능)
- 링크 수만큼 파일을 공유하고 있으며, 링크 수가 0이면 완전히 제거 가능
- 융통성이 있으며, 기억공간을 절약할 수 있으나 복잡함
- 공용된 파일이나 디렉터리는 물리적으로는 한 개만 존재
- 하나의 파일이 다수의 이름으로 존재 가능
- UNIX 운영체제에서 사용 중
- 떨어진포인터(Dangling Pointer) : 없는 주소, 사용할 수 없는 해제된 주소를 가리키는 것

## 3.5 일반그래프디렉터리
<img width="300" src="https://user-images.githubusercontent.com/29009929/154219299-6bcfde0e-3f7d-4574-ab70-5f693eda8578.png">

- 사이클을 허용하므로, 파일 접근이 용이
- 하나의 파일이나 디렉터리를 상위 디렉터리에서 공용 사용 가능
- **상위 파일이나 디렉터리를 자신의 파일이나 하위디렉터리로 구성 가능**
- 파일을 제거하기 위한 자투리모음(가비지컬렉션)을 위한 참조 계수기가 필요함

---
# S2. 자원보호 및 보안
## 1. 도메인
    도메인 = 객체(Object) + 권한(Right)
    
    객체 : 컴퓨터시스템에서 보호되어야할 대상 (CPU,메모리,디스크,프린트,프로세스,파일,데이터베이스 등)
    권한 : 객체를 보호하기 위한 허가 권한 (판독/읽기 r, 쓰기/수정 w, 실행 x 등)
    
## 2. 자원보호기법 (접근제어기법)
- 컴퓨터시스템에서 보호되어야할 모든 대상의 접근목록을 두어 접근가능사용자와 가능동작을 기록한 후, 이를 근거로 접근을 허용하는 기법

## 2.1 접근제어행렬 (Access Control Matrix)
- 객체의 사용권한을 모든 사용자리스트와 함께 표시하는 행렬
- 임의의 사용자가 허용되지 않은 자원에 접근하지 못하도록 하는 기법
- 문제점 : 사용자가 많게 되면 공간낭비가 발생하여, 효율이 떨어짐
- 가로 : 권한, 세로 : 사용자 구조의 표

## 2.2 접근제어리스트 (Access Control List)
- 보호하려는 대상에 영역별로 접근권한을 부여하여 구성
- 접근제어행렬에서 허용되지 않은 사용자는 접근제어리스트에서도 제외됨
- 권한이 없는 셀을 위한 메모리를 낭비할 필요가 없어져서 효율성이 높아짐
- ex) CPU는 누구누구가 어떤 권한으로 사용가능, 메모리는 누구누구가 어떤 권한으로 사용가능

## 2.3 자격리스트 (Capability List)
- 사용자 개개인에 허용된 조작리스트
- 사용자가 시스템에 접근하면 사용자의 권한을 파악하게 됨
- ex) 시스템관리자가 가능한 조작은 CPU, 메모리, 디스크의 읽기/쓰기/실행 , 사용자1이 가능한 조작은 ~~ 

## 3. 보안유지방식
## 3.1 외부보안(External)
- 침입자 또는 화재나 홍수 같은 천재지변으로부터 컴퓨터시스템을 보호하기 위한 기능과 관련된 보안
- 백업을 주기적으로 실실하여 안전한 곳에 보관해야함
- 시설보안(침입자,천재지변으로부터 보안) / 운용보안(관리자,경영자들의 정책으로 이루어지는 통제절차에 의한 보안)

## 3.2 내부보안(Internal)
- 하드웨어나 운영체제에 내장된 기능
- 프로그램의 신뢰성있는 운영과 데이터의 무결성을 보장하기 위한 보안

## 3.3 사용자인터페이스보안
- 사용자의 신원을 운영체제가 확인하는 절차를 통해 불법침입자로부터 시스템을 보호하는 보안
- 패스워드보호 / 인증(Authentication, 인가된 사용자만 가능)

## 4. 비밀키와공개키
## 4.1 비밀키 암호 방식 (=대칭키, 공통키, Private Key System) : DES
- 암호화와 복호화 키가 동일한 키
- 정보를 교환하고 있는 사람들끼리만 비밀키를 사용해야하므로 키 분배가 어려움
- 디지털서명 어려움
- 평문을 암호화하는데 가장 많이 사용됨
- 대칭키, 관용키, 단일키, 비밀키 암호화 방식이라고 함
- DES 암호 방식이 대표적

## 4.2 공개키 암호 방식 (=비대칭키) : RSA
- 암호화와 복호화 키가 서로 다른 키
- 암호화키는 공개되지만, 복호화키는 비공개(비밀이어야함)
- 비밀키 암호방식보다 키 분배가 간단
- 디지털서명에 적당
- 암호화과정이 복잡해서 속도가 느림
- 비대칭키, 공용키 방식이라고도 함
- RSA, PGP 암호 방식이 대표적

## 4.3 기타 암호 기법
### 디지털서명
    - 메시지의 송신자 및 내용을 인증하기 위한 일련의 절차
    - 송신자가 자신의 공개키(암호화키)를 이용하여 전자서명하면, 수신자는 비밀키(복호화키)로 전자서명을 확인하고 메시지를 수신하는 기법
### 인증교환기법
    - 수신자가 메시지전송 도중에 변경되지 않았음을 확인할 수 있음
    - 메시지가 정당한 상대방으로부터 전달된 것임을 확인할 수 있는 기법
### 여분정보삽입기법
    - 불법적인 수신자에 의해 메시지가 해독될 경우를 대비하여, 
      메시지 일부분에 거짓비트(거짓내용)를 삽입하여 정상적으로 분석하지 못하도록 하는 기법

