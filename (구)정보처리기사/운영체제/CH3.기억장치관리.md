# S1. 기억장치의 계층구조
## 1. 기억장치의 계층구조
- **래 > 캐 > 주 > 보**
## 2. 기억장치의 사용용도
## 2.1 인터리빙(Interleaving)
- 주기억장치의 액세스속도를 빠르게 하기 위한 기술
- 기억장치의 연속된 위치를 서로다른 뱅크로 구성하여, 하나의 주소로 여러개의 위치에 해당하는 기억장치를 접근할 수 있도록 함
- 하나의 장치가 독립적인 기능을 하는 다른 장치의 상태를 검사할 수 있도록 허가하는 기법을 폴링(Polling)이라고 함
## 2.2 DMA(Direct Memory Access)
- 중앙처리장치(CPU)를 거치지 않고, 직접 주기억장치와 주변장치 사이에서 데이터를 주고받는 입출력 제어기
- 사이클스틸링 기법을 이용함
### 사이클스틸링
      중앙처리장치와 입출력장치가 동시에 주기억장치에 접근하려고 하는 경우, 
      입출력장치에 우선순위를 부여하는 것으로,
      적은 양의 사이클을 필요로하는 채널에 우선순위를 높여주면 입출력 장비의 효율이 높아짐

---
# S2. 기억장치의 관리기법
## 1. 주기억장치(실기억장치)의 다중프로그래밍 사용방식
## 1.1 고정분할(정적분할) : 내부 및 외부단편화O
- 주기억장치를 여러개의 고정크기로 분할하여 사용하는 방식
- 문제점 : 프로그램들의 크기와 분할된 주기억장치의 크기가 항상 같을 수 없어서 단편화가 발생함.
- 단편화된 주기억장치의 영역은 통합(Coalescing)과 집약(Compaction)을 통해서 재사용되어야함
### 내부단편화(Internal Fragmentation)
      정해진 크기에 프로그램을 할당하고 남은 기억공간으로, 
      다른 프로그램이 할당받기에는 크기가 모자라서 결국에는 사용하지 못하고 남은 공간
### 외부단편화(External Fragmentation)
      프로그램의 크기가 남은 기억공간보다 커서 할당하지 못함으로써, 사용하지 못하고 남은 공간
### 단편화의 특징
      1) 프로그램이 실행되기 위해서는, 프로그램 전체가 주기억장치에 위치하고 있어야 함
      2) 프로그램이 분할된 기억공간에 모두 들어갈 수 없는 경우가 생길 수 있음
      3) 주기억장치를 고정분할하여 사용하는 방식은 내부, 외부 단편화가 모두 발생함

## 1.2 가변분할(동적분할) : 외부단편화O
- 고정분할의 내부 및 외부 단편화 문제를 보완한 방법
- 프로그램의 크기에 따라 주기억장치 분할 크기를 동적으로 분할하는 방식
- 프로그램의 크기에 정확하게 맞게 분할하기 때문에, 내부단편화는 발생하지 않음
- 하지만, 외부단편화는 계속 발생
- 차폐레지스터(분할된영역을구분하기위한보호장치)의 값을 매번 변경해야하기 때문에 고정분할방식보다 복잡
### 가변분할의 특징
      1) 기억장치활용률 높아짐
      2) 고정분할 방식에 비해 실행될 프로세스 크기에 대한 제약이 완화됨
      3) 가변분할기억장치배당방식이라고도 함
      4) 외부단편화만 발생

## 1.3 주기억장치 재사용 기술 (통합/집약)
### 통합(Coalescing) : 인접
      인접한 공백의 기억공간을, 더 큰 하나의 공백으로 만드는 과정
### 집약(Compaction, Garbage-collection, 압축) : 떨어져있는
      서로 떨어져 있는 여러개의 낭비 공간을 모아서, 하나의 큰 기억공간으로 만드는 과정.
      사용되지 않는 기억장치를 주기억장치의 한쪽 끝으로 옮기는 것.
      디스크조각모음과 같은 의미

## 2. 가상기억장치(보조기억장치)의 사용방식
- 보조기억장치를 주기억장치처럼 사용하는 것으로, 주기억장치보다 용량이 큰 프로그램도 처리 가능
- 프로그램을 여러개의 작은 블록단위로 나누어서 가상기억장치에 보관해놓고,
  프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리함
- 사용자 프로그램이 실제기억장치보다 커도 수행 가능
- 주기억장치의 물리적공간보다 큰 프로그램도 실행 가능
- 프로그램 실행 시, 주소변환작업이 필요하기 때문에 설계가 복잡해짐
- 연속할당방식에서의 기억장치 단편화문제를 적극적으로 해결가능
- 기억장치의 이용률과 다중프로그래밍의 효율을 높일 수 있음
- 프로세스가 갖는 가상주소공간상의 연속적인 주소가, 실제기억장치에서도 연속적일 필요는 없음
- 가장기억장치의 일반적인 구현방법은 고정분할기법(페이징기법)과 가변분할기법(세그멘테이션기법)이 있음
  
## 3. 가상기억장치의 다중프로그래밍 사용방식
## 3.1 페이징기법(고정분할, 정적분할) : 내부단편화O
- 크기가 동일한 영역인 페이지(page)로 나누어 처리하는 방법
- 주기억장치와 프로그램의 크기를 동일한 크기로 고정분할
- 외부단편화는 발생하지 않지만, 내부단편화 발생
- 프로그램의 크기에 제한이 없으며, 주기억장치를 효율적으로 사용가능

### 페이징기법 특징
      - 주기억장치에 페이지 크기로 나누어진 영역을 페이지 프레임이라고함
      - 주소 변환을 위해 페이지 맵 테이블을 요구
      - 가상메모리를 물리주소로 변환하는 오버헤드가 발생
      - 논리주소를 물리주소로 변환하는 것을 매핑이라고 부름
      - 페이지크기가 작을수록, 더 많은 페이지사상테이블 공간이 필요 / 내부단편화는 줄어듬 /
        자주 사용하는 페이지의 집합을 효율적으로 운영 가능 / 특정한 참조구역성만을 포함하기 때문에 기억장치효율이 높아짐
      - 페이지크기가 클수록, 페이지테이블크기가 작아지므로 주기억장치 공간이 절약되고 관리도 용이해짐
      - 각 프로그램은 분할된 자신의 영역만을 사용하므로, 프로그램이 다른 페이지들은 같은 기억공간을 공유 불가능

## 3.2 세그멘테이션기법(가변분할, 동적분할) : 외부단편화O
- 프로그램을 여러개의 다른 크기로 분할하고, 주기억장치에서는 분할된 크기에 맞게 동적으로 분할하여 적재시키는 방법
- 가상 메모리를 서로 크기가 다른 논리적 단위로 분할한 것을 의미
- 프로세스를 물리적 단위인 페이지가 아닌, 논리적 단위인 세그먼트로 분할해서 메모리에 적재하는 방식
- 세그먼트사상테이블이 필요
- 외부단편화만 발생
- 빈공간이 생기는 현상을 체커보딩이라고 함
- 각 프로그램은 분할된 자신만의 영역이 없으므로, 다른 프로그램의 세그먼트들은 같은 기억공간을 공유함

## 4. 가상기억장치주요기술
## 4.1 오버레이(Overlay) : 순차적재하여 실행
- 주기억장치의 용량보다 큰 프로그램들을 분할한 뒤, 분할된 프로그램들을 순차적으로 적재하여 실행
- 실행 중에 주기억장치의 메모리가 부족하면 불필요한 조각이 있는 곳에 새로운 조각을 중첩하여 적재합니다.
## 4.2 스와핑(Swapping) : 교체하여 실행
- 주기억장치의 용량보다 큰 프로그램들을 분할한 뒤, 보조기억장치에 적재된 다른 프로그램의 메모리와 교체하여 실행
- Swap Out: 주기억장치에 있는 프로그램이 보조기억장치로 이동
- Swap In: 보조기억장치에 있는 프로그램이 주기억장치로 이동
## 4.3 페이지부재(PageFault)
- 프로그램에서 접근하려고하는 페이지가 주기억장치에 있지 않은 경우 발생하는 현상
## 4.4 스래싱(Thrashing)
- 하나의 프로세스가 작업수행과정 중 지나치게 페이지부재가 발생함으로 인하여, 전체 시스템의 성능이 저하되는 현상
- 지속적인 페이지부재로 인하여, 프로세스 처리시간보다 페이지 교체 시간이 더 많이 발생하는 현상
- 다중프로그래밍 정도가 높아질수록 CPU이용률은 증가하지만, 너무 높으면 스래싱이 발생할 수 있음
### 스래싱 현상 방지방법
      - 다중프로그래밍의 정도를 낮추기 (동시에 실행되는 프로그램의 수 줄이기)
      - CPU이용률 높이기 (적당히)
      - 페이지부재율을 조절하여 대처하기
      - 자주 사용하는 페이지들을 주기억장치에 미리 가져다놓기 (워킹셋 이용)

## 4.5 구역성(Locality)
- Denning 교수에 의해 증명됨
- 프로그램이 실행할 때 기억장치 내의 모든 정보를 균일하게 창조하는 것이 아니라,
- 어느 한 순간에 특정부문을 집중적으로 참조하는 것
### 시간구역성(Temporal)
      - 최근에 참조된 기억장소가 가까운 장래에도 계속 참조될 가능성이 높음
      - 종류 : 반복(Loop), 부프로그램(서브루틴), 스택, 집계(Count,Total) 시 사용되는 변수들
### 공간구역성(Spatial)
      - 하나의 기억장소가 참조되면 그 근처의 기억장소가 계속 참조될 가능성이 높음
      - 종류 : 배열순회(Array Traversal), 프로그램의 순차적코드실행, 
              프로그램에서 관련된 변수들을 서로 근처에 선언하는 경우
              
### 4.6 워킹셋(Working Set)            
- Denning이 제안한 모델
- 자주 참조하는 페이지들의 집합
- 주기억장치에 미리 적재해두면 페이지폴트를 최소화할 수 있고 효율적인 실행이 가능 

---
# S3. 기억장치의 관리전략
## 1. 기억장치 관리전략의 종류
## 1.1 반입전략(Fetch Strategy)
- 프로그램/데이터를 주기억장치로 가져오는 시기를 결정하는 전략
- 요구반입, 예상반입
### 요구반입(Demand)
      - 요구가 있을 때마다 주기억장치로 옮기는 방법
### 예상반입(Anticipatory)
      - 앞으로 요구될 가능성이 큰 프로그램 또는 데이터를 예상하여, 주기억장치로 미리 옮기는 방법
      - 가상기억장치(보조기억장치)를 사용하게 될 때 주로 사용
      - 예상이 성공하면 프로그램의 실행속도가 빨라지지만, 실패하면 오버헤드(부가작업)가 발생
      
      - 자주 사용하는 페이지는 미리 주기억장치에 가져다 놓는다 (워킹셋)
      - 앞으로 사용할 가능성이 높은 페이지를 가져다 놓는다 (구역성)

## 1.2 배치전략(Placement)
### 최초적합(First Fit)
      - 입력된 작업을 수용할 수 있는 첫번째 공백에 배치
      - 내부단편화의 크기에 상관없이 단편화가 많이 발생
      - 초기결정력이 가장 빠름
### 최적적합(Best Fit)
      - 입력된 작업이 가장 잘 맞는 공백에 배치
      - 작업과 프로세스 크기 차가 가장 작은 곳에 배치
      - 내부단편화가 가장 적게 발생
      - 검색시간이 길어져 결정력이 느림
### 최악적합(Worst Fit)
      - 입력된 작업을 가장 잘 맞지 않는 공백에 배치
      - 작업과 프로세스 크기 차가 가장 큰 곳에 배치
      - 내부단편화가 가장 크게 발생
      
## 1.3 교체전략(Replacement, 재배치)
### OPT (OPtime Replacement, 최적) : 앞으로 가장 오랫동안 사용되지 않을 페이지와 교체
      - 앞으로 가장 오랫동안 사용되지 않을 페이지와 교체
      - 페이지 사용횟수를 정확히 예측하여 교체하는 방법
      - Belady의 알고리즘으로 가장 이상적이지만, 실행가능성이 희박
      - 페이지부재(페이지폴트) 횟수가 가장 적으므로 성공률(히트)이 가장 높음
      
### FIFO : 가장 오래된 페이지와 교체
      - 주기억장치내의 가장 오래된 페이지와 교체
      - 페이지교체가 가장 많으며, 페이지부재(페이지폴트)가 가장 많이 발생

      [Belady의 모순]
      프로세스에 할당된 페이지프레임 수가 증가하면 페이지부재의 수가 감소하는 것이 당연하지만,
      페이지프레임 수가 증가할 때, 현실적으로 페이지부재가 더 증가하는 모순 현상

### LRU (Least Recently Used) : 현 시점에서 가장 오랫동안 사용하지 않은 페이지와 교체
      - 현 시점에서 가장 오랫동안 사용하지 않은 페이지와 교체
      - 각 페이지마다 계수기(시간기억영역)를 두어 사용하는 방법

### LFU (Least Frequently Used) : 참조된 횟수가 가장 적은 페이지와 교체
      - 참조된 횟수가 가장 적은 페이지와 교체

### NUR (Not Used Recently) : 최근에 사용되지 않은 페이지와 교체
      - 최근에 사용되지 않은 페이지와 교체
      - 페이지당 두개의 정보비트(참조비트, 변형비트)를 이용하여 교체하는 방법
      - 참조비트 : 해당 페이지를 호출했는지 파악하는 비트
      - 변형비트 : 주기억장치내에 있던 페이지를 사용했는자 의미
      - 비트값이 1이면 최근사용, 0이면 오래전에 사용으로 판단

### PFF (Page Fault Frequently) : 자주 참조하는 페이지들은 주기억장치에 미리 적재하여 페이지폴트를 최소화
      - 자주 참조하는 페이지들은 주기억장치에 미리 적재하여 페이지폴트를 최소화 되도록 함
      - 자주 참조하는 페이지의 집합을 워킹셋이라고 하는데,
      - PFF는 워킹셋에 존재하는 페이지들을 관찰하여, 최근에 자주 사용되고 있지 않은 페이지와
        워킹셋에 속하지 않는 페이지 중에 최근에 자주 사용하는 페이지를 서로 교체하여 교체효율을 높이는 방법
  
## 2. 주기억장치의 할당과 회수
- 주기억장치에 프로그램이 적재될 때, 빈공간이 있는지 또는 크기가 어느정도인지 우선 파악해둬야 신속 적재 가능
## 2.1 비트맵
- 분할된 기억장치영역의 정보를 0 또는 1로 구분하여 영역이 사용중이면 1, 사용중이지 않으면 값을 세팅
- 분할된 블록(페이지, 세그먼트)의 크기가 크면 비트맵 용량이 줄어듬 (작으면 반대로 비트맵 용량이 늘어남)
- 사용되지 않는 영역이 있거나, 단편화가 발생해도 통합과 집약이 어려움
- 사용여부를 알아내기 위해서 '순차검색'만을 하므로 검색속도가 떨어짐

## 2.2 연결리스트(Linked List)
- 분할된 영역의 정보를 구조적인변수(레코드)로 확보하여, 동적인 연결구조인 연결리스트 구조로 관리
- 배치전략에 사용하기 적합
- 추가 및 삭제가 용이하므로, 통합과 집약에 효과적 사용 가능
- 비트맵보다는 검색속도가 다소 느림

## 3. 기억장치의 주소 사상 방법
## 3.1 블록사상(페이지, 세그먼트) 주소 양식 
      V = (B, D)
      
      B = 페이지, 세그먼트 번호
      D = displacement(시작주소로부터 떨어진거리 = 시작주소에 D값을 더하면 됨, offset)

## 3.2 블록(페이지, 세그멑트) 주소 사상 기법 종류
### 직접사상(Direct Mapping)
      페이지매핑테이블에서 얻은 실기억장치의 주소와 가상주소의 변위(값의 차?)를 실제주소로 변환하는 방법
### 연관사상(Associative Mapping)
      - 고속의 연관메모리에 자주 사용하는 페이지만 기억시키거나, 
        혹은 현재 적재된 페이지만을 기억시켜 속도를 향상시키는 방법
        
      - 직접사상은 페이지 분할개수가 많을 수록 해당페이지 검색 시간이 많이 소요되고, 프로그램을 가상기억장치로 실행 시
        페이지교체 속도가 늦어져 전체 프로그램의 실행속도에 영향을 주는 단점을 보완한 방식

### 연관/직접사상(Set Associative Mapping)
      - 우선 연관사상기법으로 해당 페이지를 찾고, 페이지가 존재하지 않으면 직접사상기법으로 검색하여 사용하는 방법
      - 연관사상기법으로 모든 페이지의 정보를 기억 시, 값비싼 고속메모리를 많이 사용해야한느 비용 문제를 보완한 방법

---
# S4. 디스크관리
## 1. 디스크 접근시간과 스케줄링
## 1.1 디스크 접근시간
- 탐색시간(Seek Time) : 디스크 상의 원하는 데이터 액세스를 위해 트랙 또는 실린더에 **헤드를 위치시키는데 걸리는 시간**
- 회전지연시간(Latency Time, Rotation Delay) : 지정된 트랙에 위치한 **헤드가 원하는 섹터에 도달할 때 걸리는 시간**
- 전송시간(Transmission Time) : **디스크로부터 주기억장치로 데이터가 이동하는 시간**

## 1.2 디스크 스케줄링
- 디스크에서 어떻게 하면 신속하게 많은 양의 데이터를 가져오는지 운영체제가 고민하고 계획하는 것
- 목적 : 처리량 최대화 / 응답시간 최소화 / 응답시간의 편차 최소화

## 2. 디스크 스케줄링 종류 및 특징 (p.252)
## 2.1 FCFS (First Come First Served, FIFO)
- **도착순서에 따라** 실행순서가 고정되므로 공평함
- 디스크의 부하가 적을 때 유리
- 디스크의 부하가 커지면 응답시간이 길어짐
- 탐색시간(Seek Time)을 최적화히려는 시도가 없음(순서대로 위치하므로, 원하는 곳으로 이동하기 위한 시간이 필요없음)

<img width="250" src="https://user-images.githubusercontent.com/29009929/154073526-5c5cbec4-7ee1-4ff4-84aa-ccc3896accf7.png">

## 2.2 SSTF (Shortest Seek Time First) 최소탐색시간우선
- **현재의 헤드위치에서 가장 가까운 입출력 요청을 먼저 서비스**
- 즉, 헤드의 탐색거리가 가장 짧은 요청을 먼저 서비스
- 가운데 트랙이 안쪽이나 바깥쪽보다 서비스받을 확률이 높음
- 헤드에서 멀리 떨어진 요청은 기아상태(무한정기다리는상태)가 발생 가능
- FCFS보다 처리량이 많고, 평균응답시간이 길다
- 처리량이 많기 때문에 일괄처리에 유용
- 응답시간의 편차가 크기 때문에, 대화형 시스템에는 부적합

<img width="250" src="https://user-images.githubusercontent.com/29009929/154073400-c9359195-f89d-451f-95ff-cbee86b7888b.png">

## 2.3 SCAN
- 헤드는 이동하는 중인 방향의 앞쪽에 더이상 요청이 없을 경우에만 후퇴 가능
  (진행방향으로 끝까지 진행)
- **진행방향이 정해지면, 같은 방향에 있는 가장 짧은 탐색시간을 갖는 요청을 우선 서비스**
  (진행방향 상의 가장 짧은 거리에 있는 요청을 먼저 수행. 진행방향은 제시되는듯)
- SSTF의 문제점인 응답시간의 편차 극복을 위해 Denning이 개발한 방법
  (안쪽과 바깥쪽의 차별대우를 최소화하고 응답시간의 편차를 줄임)
- 헤드가 디스크 표면을 양방향(안쪽/바깥쪽)으로 이동하면서 입출력 요청을 서비스
- 대부분의 디스크 스케줄링의 기본이 됨
- 부하가 적은 경우에는 SCAN기법이 가장 좋은 결과를 가짐  

<img width="250" src="https://user-images.githubusercontent.com/29009929/154073057-0ab2e40b-deaa-447c-8ea6-3a593c0b26a4.png">

## 2.4 C-SCAN
- SCAN의 문제점인 안쪽과 바깥쪽의 차별대우를 아예 없애기 위해, 
  항상 바깥쪽에서 안쪽으로 움직이면서 가장 짧은 탐색시간을 가진 요청을 우선 서비스
  (작은값부터 정렬했을 때, 0부터 시작되는 왼쪽이 바깥쪽, 오른쪽이 안쪽)
- **헤드는 트랙의 안쪽으로 한방향으로만 움직이며, 안쪽에 더 이상 입출력요청이 없으면,
  완전 반대 바깥쪽으로 이동한 뒤 다시 안쪽으로 이동하면서 입출력 요청을 서비스**
- 안쪽 방향으로 끝까지 진행
- 응답시간의 편차가 매우 적음
- 부하가 많은 경우에는 C-SCAN기법이 가장 좋은 결과를 가짐

<img width="250" src="https://user-images.githubusercontent.com/29009929/154073327-b2d4f225-0266-43d8-8e57-26e4745defee.png">

## 2.5 LOOK과 C-LOOK
- 진행방향에 더 이상의 요청이 있는지 확인하는 방식
- 헤드는 각 방향으로 요청에 따라는 거리만큼을 이동하고, 현재 방향에서 더 이상의 요청이 없다면 헤드의 이동방향이 바뀌는 방식
- SCAN과 C-SCAN 스케줄링이 요청이 없는 경우에도 헤드의 끝까지 진행해 시간낭비를 하는 것을 보완한 방식
- 엘리베이터 운행방식과 동일하여 엘리베이터 스케줄링이라고도 함

## 2.6 N-Step SCAN
- 어떤 방향의 진행이 시작될 당시 대기중이던 요청들만 서비스하고, 
  진행 도중 도착한 요청들은 한데 모아서, 다음 진행 때 최적으로 서비스할 수 있도록 배열됨
- 즉, 대기중에 있는 요청들은 1차적으로 받아서 진행시키고, 진행을 시작한 뒤에 들어온 요청은 받아들이지 않음
- 그리고 진행이 모두 끝나고 난 뒤에 2차적으로 서비스 진행

## 2.7 에센바흐(Eschenbach)
- **부하가 매우 큰 항공예약시스템을 위해 개발**됨
- 탐색시간 뿐만아니라, 회전지연시간의 최적화를 위해 개발된 기법
- 헤드는 C-SCAN처럼 움직이며, 예외적으로 모든 실린더는 그 실린더의 요청이 있거나 없어도 
  전체 트랙이 한바퀴 회전할동안 서비스를 받음
- 탐색시간과 회전지연시간을 모두 고려해 개발된 스케줄링이지만, 디스크드라이브의 물리적인 성질때문에
  오히려 응답시간이 늘어나서 거의 사용하지 않는 기법


