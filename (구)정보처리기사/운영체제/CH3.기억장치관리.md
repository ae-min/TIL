# S1. 기억장치의 계층구조
## 1. 기억장치의 계층구조
- **래 > 캐 > 주 > 보**
## 2. 기억장치의 사용용도
## 2.1 인터리빙(Interleaving)
- 주기억장치의 액세스속도를 빠르게 하기 위한 기술
- 기억장치의 연속된 위치를 서로다른 뱅크로 구성하여, 하나의 주소로 여러개의 위치에 해당하는 기억장치를 접근할 수 있도록 함
- 하나의 장치가 독립적인 기능을 하는 다른 장치의 상태를 검사할 수 있도록 허가하는 기법을 폴링(Polling)이라고 함
## 2.2 DMA(Direct Memory Access)
- 중앙처리장치(CPU)를 거치지 않고, 직접 주기억장치와 주변장치 사이에서 데이터를 주고받는 입출력 제어기
- 사이클스틸링 기법을 이용함
### 사이클스틸링
      중앙처리장치와 입출력장치가 동시에 주기억장치에 접근하려고 하는 경우, 
      입출력장치에 우선순위를 부여하는 것으로,
      적은 양의 사이클을 필요로하는 채널에 우선순위를 높여주면 입출력 장비의 효율이 높아짐

---
# S2. 기억장치의 관리기법
## 1. 주기억장치(실기억장치)의 다중프로그래밍 사용방식
## 1.1 고정분할(정적분할) : 내부 및 외부단편화O
- 주기억장치를 여러개의 고정크기로 분할하여 사용하는 방식
- 문제점 : 프로그램들의 크기와 분할된 주기억장치의 크기가 항상 같을 수 없어서 단편화가 발생함.
- 단편화된 주기억장치의 영역은 통합(Coalescing)과 집약(Compaction)을 통해서 재사용되어야함
### 내부단편화(Internal Fragmentation)
      정해진 크기에 프로그램을 할당하고 남은 기억공간으로, 
      다른 프로그램이 할당받기에는 크기가 모자라서 결국에는 사용하지 못하고 남은 공간
### 외부단편화(External Fragmentation)
      프로그램의 크기가 남은 기억공간보다 커서 할당하지 못함으로써, 사용하지 못하고 남은 공간
### 단편화의 특징
      1) 프로그램이 실행되기 위해서는, 프로그램 전체가 주기억장치에 위치하고 있어야 함
      2) 프로그램이 분할된 기억공간에 모두 들어갈 수 없는 경우가 생길 수 있음
      3) 주기억장치를 고정분할하여 사용하는 방식은 내부, 외부 단편화가 모두 발생함

## 1.2 가변분할(동적분할) : 외부단편화O
- 고정분할의 내부 및 외부 단편화 문제를 보완한 방법
- 프로그램의 크기에 따라 주기억장치 분할 크기를 동적으로 분할하는 방식
- 프로그램의 크기에 정확하게 맞게 분할하기 때문에, 내부단편화는 발생하지 않음
- 하지만, 외부단편화는 계속 발생
- 차폐레지스터(분할된영역을구분하기위한보호장치)의 값을 매번 변경해야하기 때문에 고정분할방식보다 복잡
### 가변분할의 특징
      1) 기억장치활용률 높아짐
      2) 고정분할 방식에 비해 실행될 프로세스 크기에 대한 제약이 완화됨
      3) 가변분할기억장치배당방식이라고도 함
      4) 외부단편화만 발생

## 1.3 주기억장치 재사용 기술 (통합/집약)
### 통합(Coalescing) : 인접
      인접한 공백의 기억공간을, 더 큰 하나의 공백으로 만드는 과정
### 집약(Compaction, Garbage-collection, 압축) : 떨어져있는
      서로 떨어져 있는 여러개의 낭비 공간을 모아서, 하나의 큰 기억공간으로 만드는 과정.
      사용되지 않는 기억장치를 주기억장치의 한쪽 끝으로 옮기는 것.
      디스크조각모음과 같은 의미

## 2. 가상기억장치(보조기억장치)의 사용방식
- 보조기억장치를 주기억장치처럼 사용하는 것으로, 주기억장치보다 용량이 큰 프로그램도 처리 가능
- 프로그램을 여러개의 작은 블록단위로 나누어서 가상기억장치에 보관해놓고,
  프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리함
- 사용자 프로그램이 실제기억장치보다 커도 수행 가능
- 주기억장치의 물리적공간보다 큰 프로그램도 실행 가능
- 프로그램 실행 시, 주소변환작업이 필요하기 때문에 설계가 복잡해짐
- 연속할당방식에서의 기억장치 단편화문제를 적극적으로 해결가능
- 기억장치의 이용률과 다중프로그래밍의 효율을 높일 수 있음
- 프로세스가 갖는 가상주소공간상의 연속적인 주소가, 실제기억장치에서도 연속적일 필요는 없음
- 가장기억장치의 일반적인 구현방법은 고정분할기법(페이징기법)과 가변분할기법(세그멘테이션기법)이 있음
  
## 3. 가상기억장치의 다중프로그래밍 사용방식
## 3.1 페이징기법(고정분할, 정적분할) : 내부단편화O
- 크기가 동일한 영역인 페이지(page)로 나누어 처리하는 방법
- 주기억장치와 프로그램의 크기를 동일한 크기로 고정분할
- 외부단편화는 발생하지 않지만, 내부단편화 발생
- 프로그램의 크기에 제한이 없으며, 주기억장치를 효율적으로 사용가능

### 페이징기법 특징
      - 주기억장치에 페이지 크기로 나누어진 영역을 페이지 프레임이라고함
      - 주소 변환을 위해 페이지 맵 테이블을 요구
      - 가상메모리를 물리주소로 변환하는 오버헤드가 발생
      - 논리주소를 물리주소로 변환하는 것을 매핑이라고 부름
      - 페이지크기가 작을수록, 더 많은 페이지사상테이블 공간이 필요 / 내부단편화는 줄어듬 /
        자주 사용하는 페이지의 집합을 효율적으로 운영 가능 / 특정한 참조구역성만을 포함하기 때문에 기억장치효율이 높아짐
      - 페이지크기가 클수록, 페이지테이블크기가 작아지므로 주기억장치 공간이 절약되고 관리도 용이해짐
      - 각 프로그램은 분할된 자신의 영역만을 사용하므로, 프로그램이 다른 페이지들은 같은 기억공간을 공유 불가능

## 3.2 세그멘테이션기법(가변분할, 동적분할) : 외부단편화O
- 프로그램을 여러개의 다른 크기로 분할하고, 주기억장치에서는 분할된 크기에 맞게 동적으로 분할하여 적재시키는 방법
- 가상 메모리를 서로 크기가 다른 논리적 단위로 분할한 것을 의미
- 프로세스를 물리적 단위인 페이지가 아닌, 논리적 단위인 세그먼트로 분할해서 메모리에 적재하는 방식
- 세그먼트사상테이블이 필요
- 외부단편화만 발생
- 빈공간이 생기는 현상을 체커보딩이라고 함
- 각 프로그램은 분할된 자신만의 영역이 없으므로, 다른 프로그램의 세그먼트들은 같은 기억공간을 공유함

## 4. 가상기억장치주요기술
## 4.1 오버레이(Overlay) : 순차적재하여 실행
- 주기억장치의 용량보다 큰 프로그램들을 분할한 뒤, 분할된 프로그램들을 순차적으로 적재하여 실행
- 실행 중에 주기억장치의 메모리가 부족하면 불필요한 조각이 있는 곳에 새로운 조각을 중첩하여 적재합니다.
## 4.2 스와핑(Swapping) : 교체하여 실행
- 주기억장치의 용량보다 큰 프로그램들을 분할한 뒤, 보조기억장치에 적재된 다른 프로그램의 메모리와 교체하여 실행
- Swap Out: 주기억장치에 있는 프로그램이 보조기억장치로 이동
- Swap In: 보조기억장치에 있는 프로그램이 주기억장치로 이동
## 4.3 페이지부재(PageFault)
- 프로그램에서 접근하려고하는 페이지가 주기억장치에 있지 않은 경우 발생하는 현상
## 4.4 스래싱(Thrashing)
- 하나의 프로세스가 작업수행과정 중 지나치게 페이지부재가 발생함으로 인하여, 전체 시스템의 성능이 저하되는 현상
- 지속적인 페이지부재로 인하여, 프로세스 처리시간보다 페이지 교체 시간이 더 많이 발생하는 현상
- 다중프로그래밍 정도가 높아질수록 CPU이용률은 증가하지만, 너무 높으면 스래싱이 발생할 수 있음
### 스래싱 현상 방지방법
      - 다중프로그래밍의 정도를 낮추기 (동시에 실행되는 프로그램의 수 줄이기)
      - CPU이용률 높이기 (적당히)
      - 페이지부재율을 조절하여 대처하기
      - 자주 사용하는 페이지들을 주기억장치에 미리 가져다놓기 (워킹셋 이용)

## 4.5 구역성(Locality)
- Denning 교수에 의해 증명됨
- 프로그램이 실행할 때 기억장치 내의 모든 정보를 균일하게 창조하는 것이 아니라,
- 어느 한 순간에 특정부문을 집중적으로 참조하는 것
### 시간구역성(Temporal)
      - 최근에 참조된 기억장소가 가까운 장래에도 계속 참조될 가능성이 높음
      - 종류 : 반복(Loop), 부프로그램(서브루틴), 스택, 집계(Count,Total) 시 사용되는 변수들
### 공간구역성(Spatial)
      - 하나의 기억장소가 참조되면 그 근처의 기억장소가 계속 참조될 가능성이 높음
      - 종류 : 배열순회(Array Traversal), 프로그램의 순차적코드실행, 
              프로그램에서 관련된 변수들을 서로 근처에 선언하는 경우
              
### 4.6 워킹셋(Working Set)            
- Denning이 제안한 모델
- 자주 참조하는 페이지들의 집합
- 주기억장치에 미리 적재해두면 페이지폴트를 최소화할 수 있고 효율적인 실행이 가능 

---
# S3. 기억장치의 관리전략
## 1. 기억장치 관리전략의 종류
## 1.1 반입전략(Fetch Strategy)
- 프로그램/데이터를 주기억장치로 가져오는 시기를 결정하는 전략
- 요구반입, 예상반입
### 요구반입(Demand)
      - 요구가 있을 때마다 주기억장치로 옮기는 방법
### 예상반입(Anticipatory)
      - 앞으로 요구될 가능성이 큰 프로그램 또는 데이터를 예상하여, 주기억장치로 미리 옮기는 방법
      - 가상기억장치(보조기억장치)를 사용하게 될 때 주로 사용
      - 예상이 성공하면 프로그램의 실행속도가 빨라지지만, 실패하면 오버헤드(부가작업)가 발생
      
      - 자주 사용하는 페이지는 미리 주기억장치에 가져다 놓는다 (워킹셋)
      - 앞으로 사용할 가능성이 높은 페이지를 가져다 놓는다 (구역성)

## 1.2 배치전략(Placement)
### 최초적합(First Fit)
      - 입력된 작업을 수용할 수 있는 첫번째 공백에 배치
      - 내부단편화의 크기에 상관없이 단편화가 많이 발생
      - 초기결정력이 가장 빠름
### 최적적합(Best Fit)
      - 입력된 작업이 가장 잘 맞는 공백에 배치
      - 작업과 프로세스 크기 차가 가장 작은 곳에 배치
      - 내부단편화가 가장 적게 발생
      - 검색시간이 길어져 결정력이 느림
### 최악적합(Worst Fit)
      - 입력된 작업을 가장 잘 맞지 않는 공백에 배치
      - 작업과 프로세스 크기 차가 가장 큰 곳에 배치
      - 내부단편화가 가장 크게 발생
      
## 1.3 교체전략(Replacement, 재배치)

















