# S1. 프로세스개념
## 1. 프로세스 개념
- 주기억장치에 상주된 프로그램이 CPU에 의해서 처리되는 상태
- 운영체제가 관리하는 최소단위의 작업(프로그램)

      - CPU에 의해서 현재 실행되고 있는 프로그램
      - PCB의 존재로서 명시되는 것
      - 디스패치가 가능한 단위 
        (디스패치 : 준비상태에서 대기하고 있는 프로세스 중 하나가 CPU를 할당받아 실행상태로 변하는 시점)
      - 비동기적 행위를 일으키는 주체
        (비동기적행위 : 다중프로그래밍 방식에서 CPU가 하나의 프로그램만을 연속적으로 처리하지 않고, 
                       여러 프로그램의 일부분을 반복적으로 실행하고 중단하는 행위
      - 프로시저가 활동 중인 상태

## 2. 프로세스의 상태
## 2.1 프로세스 상태 전이도
     
<img width="350" src="https://user-images.githubusercontent.com/29009929/153714239-64045644-0e00-45a5-b390-559b050d7a23.png">

    - 준비 : CPU를 사용하고 있지는 않지만 언제든지 사용할 수 있는 상태, CPU에 의해 처리되기 위해 주기억장치에 존재하는 상태
    - 실행 : 프로세스가 CPU를 차지하고 있는 상태, 프로세스의 명령이 실행되고 있는 상태
    - 대기 : 프로세스가 어떤 사건이 일어나기를 기다리고 있는 상태, 처리속도가 느린 입출력 작업중인 상태
    - 디스패치 : 준비상태에 있는 여러 프로세스 중, 한 프로세스를 선정하여 CPU를 할당하는 시점
    - I/O발생 : 프로세스가 CPU사용중에 I/O(입출력)행위가 필요하여 대기상태로 이동하는 시점
    - 깨움 : 입출력 작업이 완료되어 준비상태로 이동하는 시점
    - 프로세스의 모든 자원 이용 순서는 요청->사용->해제
    
---
# S2. 인터럽트 처리
## 1. 인터럽트 개념
## 1.1 인터럽트
      - 프로세스가 수행 중에 다른 프로세스 수행을 위해 현재 수행 중인 프로세스를 중단하거나,  
        외부입력장치에 의해 프로세스가 중단되는 현상
      - 현재 프로세스를 중단시키는 모든 행위
## 1.2 인터럽트 작업 순서
      1) 인터럽트 발생 시, 운영체제가 제어권 받음
      2) 운영체제는 인터럽트 받은 현재의 프로세스 상태를 저장
      3) 운영체제는 인터럽트 정보를 분석하여 지정되어있는 루틴으로 제어권을 넘겨줌
      4) 인터럽트 처리 루틴이 인터럽트 처리
      5) 인터럽트가 걸렸던 이전의 프로세스 상태로 복구
      6) 인터럽트가 걸렸던 시점 이후부터 

## 3. 문맥교환
     - 다중프로그래밍 시스템에서 CPU가 할당되는 프로세스를 변경하기 위하여, 현재 CPU를 사용하여 실행되고 있는
       프로세서의 상태 정보를 저장하고, 제어권을 인터럽트 서비스 루틴에게 넘기는 작업
     - 프로세스의 중단과 실행 시 인터럽트가 발생하므로, 문맥교환이 많이 일어난다는 것은 인터럽트가 많이 발생한다는 것

---
# S3. 중앙처리장치(CPU)스케줄링 (=프로세스스케줄링)
## 1. 프로세스스케줄링 성능평가 기준 (CPU이용률/처리능력/대기시간/응답시간/반환시간)
      1) 처리능력(Throughput) : 단위시간당 처리할 수 있는 CPU의 작업량
      2) 대기시간(Waiting Time) : 준비상태에서 대기하는 시간
      3) 응답시간(Response Time, 반응시간) : 입력에 대해 처음 반응하는 시간
      4) 반환시간(Turn-around Time) : 작업을 지시하고, 그 결과가 되돌아오는 시간
## 1.1 큐(Queue)
- 한쪽에서 삽입하고, 다른 한쪽에서는 삭제하는 메모리 사용방식으로, 선입선출(FIFO)방식으로 접근되는 대기 리스트
- 선형 큐 : 앞부분과 끝부분이 연결되어있지 않은 큐, 주로 직선형태
- 환형 큐 : 앞부분과 끝부분이 연결되어 있어 원 형태로 사용하는 큐

## 2. 프로세스스케줄링 알고리즘
## 2.1 비선점형방식과 선점형방식의 비교
### 비선점(Non Preemptive)
      - 프로세스가 CPU에 할당되면, 권한을 빼앗을 수 없음
      - 일괄처리방식에 적당
      - 대화형, 시분할, 실시간 시스템에 부적당
      - FIFO, SJF, HRN, 우선순위, 기한부 방식
      - 문맥교환이 적어 오버헤드(실행을위한부가적노력)가 적음
### 선점(Preemptive)
      - 프로세스가 CPU에 할당되면, 우선순위가 높으면 빼앗을 수 있음
      - 일괄처리방식에 부적당
      - 대화형, 시분할, 실시간 시스템에 적당
      - RR(라운드로빈), SRT, MFQ 방식
      - 문맥교환이 많아 오버헤드가 

## 3. 비선점형방식
## 3.1 FIFO 
- 먼저 입력된 작업을 먼처 처리하는 방식으로 가장 간단함
- 공평하고 구현이 간단하나, 평균반환시간이 길다
- 짧은 작업이나 중요한 작업을 오랫동안 기다리게 할 수 있음
- 평균반환시간 = 평균실행시간+평균대기시간
- 제출시간이 있는 경우, 대기시간 계산시 제출시간을 빼고 계산하면됨 (p193)

## 3.2 SJF (Shortest Job First, 최단작업우선)
- **실행시간 추정치가 가장 작은 작업(최단작업)을 먼저 실행**시키는 방식
- 짧은 작업들을 우선 처리하기 때문에, 대기리스트 안에 있는 작업의 수를 최소화시키면서, 평균반환시간 최소화 가능
- 긴 작업일지라도 이미 CPU를 점유하고 있다면 뒤로 밀려나지 않고 처리되며, 다음작업들을 대상으로 재정리를 함
- 긴 작업인 경우, 계속되서 입력되는 짧은 작업들 때문에 우선순위가 계속 밀려나게 되고, **무한연기상태가 발생하기도 함**
- FIFO를 개선한 방식
- 무한연기현상을 방지하기 위해 **에이징기법 사용**
- 제출시간이 있는 경우, 제출시간이 가장 빠른 작업을 우선대기리스트에 배치한 후, 나머지 작업들을 짧은작업 순서대로 배치함
- 가장 처음 제추로딘 작업의 실행시간이 길더라도, 짧은 작업이 뺏을 수 없음
- 시분할시스템에 적용 어려움

## 3.2.1 에이징기법(Aging)
- SJF의 무한연기현상을 방지하기 위한 기법
- 오랜 시간 기다린 프로세스는, 기다린 시간에 비례하는 높은 우선순위를 부여하여 가까운 시간안에 자원이 할당되도록 하는 기법

## 3.3 HRN (Highest Response-ratio Next)
- 서비스시간과 대기시간의 비율을 고려한 스케줄링 방법
- SJF에서 발생 가능한 무한연기현상을 극복하기 위해 개발됨
- 우선순위 계산 공식 이용
- 우선순위 = (대기시간+서비스시간)/서비스시간
- 계산값이 가장 큰 작업에게 우선권 부여

## 3.4 우선순위스케줄링
- 대기리스트에 있는 프로세스들에게 작업의 우선순위를 부여하여 CPU를 할당하는 방법
- SJF스케줄링도 작업량이 적은 작업에 우선순위를 부여했으므로, 우선순위 스케줄링의 한 예라고 볼 수 있음
- 고정적우선순위와 동적우선순위방식이 있으며, 동적우선순위는 구현이 어렵고 오버헤드가 크다
- 기아현상 또는 무한봉쇄현상이 발생 가능
### 3.4.1 기아현상(Starvation, =아사현상, 무한봉쇄현상)
- 우선순위가 낮은 작업은 영원히 처리되지 않는 현상
- 에이징기법을 통해 해결 가능
## 3.5 기한부스케줄링
- 제한된 시간내에 반드시 작업이 완료되도록 스케줄링하는 방식
- 작업이 완료되는 제한된 시간을 정확히 추정하여 그 시간만큼에 CPU 사용시간을 제한함.
- 작업이 제한 시간내에 처리되지 않으면, 다시는 해당작업이 CPU 사용시간을 할당받을 수 없는 방시
- 동시에 다수의 기한부 작업 수행시 스케줄링은 어려워지고, 막대한 오버헤드 발생 가능

## 4. 선점형방식
## 4.1 라운드로빈 (RR)
- 시분할 시스템을 위해 고안된 방식
- 시간할당량(Time Slice, Quantum)이라는 작은 단위시간이 정의되어, 시간할당량만큼씩 CPU를 사용하는 방법
- 비선점의 FIFO방식을 선점형으로 변환한 방식
- 먼저 입력된 작업이라도 할당된 시간만 CPU 이용 가능
- 할당시간내에 작업을 완료하지 못할 경우, CPU는 다음 대기중인 프로세스에게로 사용권한이 넘어가고
- 현재 실행중이던 프로세스는 대기리스트의 가장 뒤로 배치됨
- 시간할당량이 적을 경우, 문맥교환에 따른 오버헤드가 커지므로 적절한 시간 배정이 중요
- 시간할당량이 크면 비선점의 FIFO와 거의 같은 형태가 됨
## 4.2 SRT (Shortest Remaining Time)
- 작업이 끝나기까지 **남아있는 실행시간의 추정치가 가장 작은 프로세스 먼저** 실행
- 비선점의 SJF와 달리, 남아있는 프로세스의 실행 추정치가 더 작은 프로세스가 있다면, 
- 언제든지 현재 작업중인 프로세스를 중단하여 더 작은 프로세스에게 CPU를 넘겨줌
- 서비스받은 시간을 기록해야하고, 실행시간을 추적해야하므로 오버헤드가 늘어남
- 평균대기시간과 대기시간의분산(편차의제곱)도 크다
- 임계치를 사용함

## 4.3 다단계피드백큐(MFQ, Multi level Feedback Queue)
- 짧은 작업이나, 입출력위주의 작업에 우선권을 위해 개발된 방식
- 큐(대기리스트)가 여러개이며, 우선순위가 있음 (맨 위에 있는 큐가 가장 우선순위가 높고 시간할당량이 적음)
- 큐마다 시간할당량이 존재하며, 낮은 큐(아래에있는 큐)일수록 시간할당량은 커짐
- 각각의 큐들은 종속적으로 연결됨
- 각 큐는 자신보다 낮은 단계의 큐들에게서 절대적인 우선순위를 가짐
- 만약 B대기리스트가 CPU를 사용중일때, 그보다 위 리스트인 A에 프로세스가 입력되면, 
- B는 바로 중단하고 A대기리스트에 있는 프로세스에게 CPU사용권한을 넘겨줘야함
- CPU를 시간할당량만큼 사용한 프로세스는 낮은 큐로 이동됨 (ex. A대기리스트에서 처리후 남은 작업은 B대기리스트로)
- 맨 마지막 큐는 라운드로빈(RR) 방식으로 처리
- 결국, 짧은 작업이나 CPU를 적게 사용하는 입출력작업들은 최상위 큐에서 빨리 처리하게 되는 방식

<img width="250" src="https://user-images.githubusercontent.com/29009929/153744646-f72fcb9f-c524-4159-a5f3-d48ddab96398.png">

## 4.4 다단계큐(MQ, Multi level Queue)
- 대기리스트를 특성별로 여러개를 가짐
- 대기리스트에 우선순위 있음 (맨위가 우선순위 가장 높)
- 각 큐는 자신보다 낮은 단계의 큐들에게서 절대적인 우선순위를 가짐
- 대기리스트마다 독립적인 스케줄링을 가짐
- 대기리스트간에 프로세스 이동 불가능
- 우선순위가 가장 높은 큐에서는 비선점형 방식으로 사용 (우선순위가 가장 높은 큐의 프로세스는 절대 뺏을 수 없음)
- 나머지 큐에서는 선점형이므로 뺏기 가능
- 선점과 비선점을 결합한 스케줄링

<img width="250" src="https://user-images.githubusercontent.com/29009929/153744672-e1e1273a-1134-4cbb-a43d-cc2fe5896f29.png">

---
# S4. 병행프로세스와 교착상태
## 1. 임계구역(Critical Section)
- 자원이 프로세스에 의하여 반납된 후, 비로소 다른 프로세스에서 자원을 이용하거나 데이터에 접근할 수 있도록 지정된 영역
- 여러개의 프로세스가 공동으로 사용하는 CPU, 메모리, 디스크, 입출력장치 등을 임계구역이라고 할 수 있음
## 1.1 임계구역의 원칙
- 두개이상의 프로세스가 동시이용 불가능
- 순서를 지키면서 신속하게 사용
- 하나의 프로세스가 독점하게 해서는 안됨
- 사용중 중단, 무한반복되서는 안됨
- 인터럽트가 불가능한 상태로 만들어야함
## 1.2 임계구역의 구현조건
- 한 프로세스가 임계구역을 수행 중인 경우, 어떤 다른 프로세스도 임계구역을 수행해서는 안됨
- 한 프로세스가 임계구역에 진입을 요청할 경우, 일정시간 내에 진입을 허락해야함
## 2. 상호배제(Multual Exclusion)
- 다른 프로세스가 현재 사용중인 임계구역을 접근하려고 할 때, 금지하는 행위를 말함
- 상호배제알고리즘 : 인터럽트불능처리, 잠금, 엄격한교대, TSL, 세마포어 등이 있음
## 2.1 상호배제알고리즘
### 인터럽트불능처리
      - 하나의 프로세스가 하나의 임계구역(공유자원)을 점유하게 되면 인터럽트를 발생하지 않도록 봉쇄함. 
      - 현재 공유자원을 점유한 프로세스는 아무런 제약없이 공유자원 사용이 가능하므로 완벽한 상호배제가 가능함
      - 하지만, 점유하고 있는 동안 다른 프로세스들은 아무런 작업을 할 수 없는 상태이므로 시스템 효율이 매우 떨어짐

### 잠금(Lock)
      - 임계구역을 점유하게 되는 경우, 그 자원을 어떠한 프로세스도 접근하지 못하도록 하는 방법
      - 공유자원을 점유하는 프로세스는, 사용을 시작하면서 공유자원에 접근하려는 
        모든 프로세스가 사용할 수 없도록 잠금표시를 함
      - 이미 점유되어있는 공유자원을 사용하기 위해 접근하고 있는 임의의 프로세스들은
        잠금표시를 계속 확인하게 되는데 이를 '바쁜대기(Busy Wait)'상태라고 함

### 엄격한교대(Dekker알고리즘)
      - 두개이상의 프로세스가 교대로 공유자원을 점유하는 방식
      - 프로세스A가 공유자원을 점유하고 나면, 프로세스B는 프로세스A가 사용해제를 통보하기를 기다렸다가 사용하는 방식

      [엄격한교대 문제점]
      - 항상 하나의 프로세스가 우선권을 갖게해야함
      - 한쪽이 작업량이 많아서 빈번해져도 반드시 교대로 점유해야함, 즉 하나의 프로세스가 연속적 재사용 불가능
      - 하나의 프로세스가 사용 중 중단되면, 다른 프로세스는 영원히 사용할 수 없는 '교착상태'에 빠지게됨
      - 한쪽 프로세스가 점유시간이 길어지면, 나머지 프로세스는 사용가능여부를 계속 감시하는 작업을 반복해야함
        (즉, 바쁜대기현상이 계속 발생함)

### TSL(Test&Set Lock) 명령어 기법
      - 엄격한교대의 문제점을 해결하는 방법으로, 특수한 하드웨어 자원을 필요로 하지만 바쁜대기상태는 완벽히 해결하지 못함

### Sleep(), Wakeup()
      - TSL의 교착상태와 바쁜대기현상의 단점 중, 바쁜대기 현상을 보완한 방법
      - 하나의 공유자원을 점유하기위한 시도를 반복하지 않고, 
        사용하려는 공유자원이 이미 사용중이라면 프로세스를 잠시 중단(Sleep)
      - 이후 어느정도의 시간이 지나서 공유자원이 사용가능하다면,
        잠시 중단하고 있던 프로세스를 활성화(Wakeup)하여 바쁜대기 방지

## 3. 세마포어(Semaphore)
- 다익스트라에의해 고안된 프로세스간의 상호배제 및 동기화문제를 해결한 방법
- P(S), V(S)등의 연산을 통해서 프로세스 사이의 동기를 유지하고, 상호배제의 원리를 보장

## 3.1 세마포어의 종류
### 이진세마포어
      - 세마포어 변수가 오직 0과 1의 값을 가지며, 하나의 임계구역만을 상호배제하기 위한 알고리즘
      - 잠금, 엄격한교대, TSL 등
### 산술세마포어
      - 세마포어 변수가 0과 양의정수 값을 가지며, 여러개의 임계구역을 관리하기 위한 알고리즘

## 3.2 세마포어의 특징
- 다익스트라가 제시한 상호배제를 위한 알고리즘
- 세마포어에 대한 연산은 처리중에 인터럽트되어서는 안됨
- 세마포어 알고리즘은 프로세스 사이의 동기를 유지하게 함
- V조작 : 대기중인 프로세스를 깨우는 신호(Wakeup), signal동작이라고도 함
- P조작 : 임계영역을 사용하려는 프로세서들의 진입여부를 결정하는 것, Wait동작이라고도 함

## 4. 모니터
- 상호배제를 위한 데이터 및 프로그램 모듈로, 운영체제 내부의 프로그램을 모니터라고 함.
- 공유자원을 사용하기위해 기다리는 프로세스들은 모니터에 진입해도 좋다는 허가를 기다리며, 
- 모니터에서는 프로세스들의 공유자원 점유순서를 제어함

## 4.1 모니터의 특징
- 모니터 외부의 프로세스는 모니터 내부의 데이터를 직접 액세스 불가
- 자료추상화와 정보은폐의 개념을 기초적으로 사용
- 스위치 개념을 사용하여 한순간에 하나의 프로세스만이 모니터에 진입가능
- 모니터에서 사용되는 연산은 wait과 signal이 있음
- 모니터의 경계에서 상호배제가 시행됨
- 두개이상의 프로세스가 특정공유자원을 순차적으로 할당하는데 필요한 데이터 및 프로시저(프로그램, 모듈, 함수)를 포함하는 병행성구조
- 모니터 내의 자원을 원하는 프로세스는 반드시 해당 모니터의 진입부를 호출해야함

## 5. 교착상태(Dead-Lock)
두개이상의 프로세스가 하나의 자원을 공유하여 사용하고 있을 때, 서로가 사용중인 자원을 요구하지만 요구를 영원히 들어줄 수 없는 상태
## 5.1 교착상태를 발생 4가지 요소(필요충분조건)
- 4가지 조건을 모두 충족할 때 교착상태 발생
### 상호배제(Mutual Exclusion)
      - 한 자원에 대한 여러 프로세스의 동시접근이 불가능하게 해야함
      - 하지만, 이러한 상호배제가 실패하게 되면 교착상태 발생
### 점유와대기(Hold & Wait)
      - 이미 한 자원을 가지고 있는 상태에서, 다른 프로세스가 사용중인 자원의 반납을 기다리는 것
### 비선점(Non Preemption)
      - 다른 프로세스의 자원을 강제로 빼앗을 수 없음
      - 자원을 빼앗을 수 없으면, 자원 사용을 위해 대기중이던 프로세스는 
        영원히 원하는 자원을 사용하지 못한채로 대기하게 되므로 교착상태 발생
### 환형대기(Circular Wait, 순환대기)
      - 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있는 것

## 5.2 교착상태 해결방안
### 예방(Prevention) : 교착상태 발생 4가지 조건 중 하나를 제거(부정)함으로써 예방
      - 상호배제 부정 : 단일 프로그램을 운영하거나, 자원을 독립적으로 사용하여 임계구역을 없애고 상호배제를 하지 않기
      - 점유와대기 부정 : 각 프로세스는 한번에 자신에게 필요한 모든 자원을 요구하도록 하고, 이 요구가 만족되지 않으면 작업이 진행불가하도록 함.
                         또한, 어떤 자원을 갖고있는 프로세스가 더 이상 요구가 수용되지 않으면, 원래 갖고있던 자원을 일단 반납하고, 
                         필요하면 다시 그 자원이나 다른 자원을 요구하도록 함으로써, 다른 자원의 반납을 기다리는 일이 없도록 함
      - 비선점 부정 : 프로세스가 점유하고 있는 자원들을 언제든 빼앗을 수 있도록 함
      - 환형대기 부정 : 환형상태(원)를 선형대기상태(직선)로 변환
                       모든 프로세스에 각 자원 유형별로 할당 순서를 부여.
                       한 프로세스가 주어진 유형의 자원을 할당받았으면, 그 프로세스는 순서에 따라 나중에 위치하는 유형의 자원만을 요구할 수 있게 함.
                       프로세스는 자신이 가지고 있는 자원보다 앞의순서 자원만들 요청하거나, 뒤의순서 자원들만을 요청해야함.
                       앞 또는 뒤 모두를 자유롭게 요청 불가능함. 

### 회피(Avoidance) : 교착상태가 발생하지 않는 범위내에서 자원분배. 다익스트라 은행원알고리즘
      
      - 프로세스가 자원 요구 시, 시스템이 안전상태를 유지할 수 있는 프로세스의 자원요구만을 할당해주는 방안
      - 교착상태 발생조건을 없애기 보다는, 발생하지 않도록 알고리즘을 적용하는 방법
      
      [은행원알고리즘(Banker's Algorithm) 특징]
      - 다익스트라 제안
      - 불안전상태와 안전상태로 구분
      - 안전상태에서는 교착상태 발생하지 않음
      - 은행원알고리즘 적용을 위해서는 자원의 양과, 사용자의 수가 일정해야함
      - 은행원알고리즘은 모든 요구를 정해진 시간안에 할당하는 것을 보장해야함 
      - 응답시간이 보장되어야하는 대회식시스템에 적용하기 어려움

### 회복(Recovery) : 교착상태 발생을 아예 막지않고, 만약, 교착상태가 발생하면 발생이후에 문제를 해결하는 방법
      - 교착상태 발생 후, 컴퓨터시스템이 다시 원만히 작동될 수 있도록 조치를 취함
      - 실행을 중단시키거나, 점유중인 자원을 빼앗을 프로세스를 찾는 일로 가능한 손실이 적은 쪽을 선택해야함
      - 우선 프로세스를 중단하고, 중단해서도 회복이 안되면 제거를 해야함

      [4가지회복방안]
      1) 선점을 통한 회복 : 보유하고 있는 자원을 빼앗아 교착상태를 해결하고 시스템 정상 회복
                           우선순위가 낮은 프로세스 / 진행상태가 적은 프로세스 / 자원을 적게 사용하고 있는 
                           자원을 선점하여 프로세스를 일시중단시킴
      2) 
                           







