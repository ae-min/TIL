# S1. 프로세스개념
## 1. 프로세스 개념
- 주기억장치에 상주된 프로그램이 CPU에 의해서 처리되는 상태
- 운영체제가 관리하는 최소단위의 작업(프로그램)

      - CPU에 의해서 현재 실행되고 있는 프로그램
      - PCB의 존재로서 명시되는 것
      - 디스패치가 가능한 단위 
        (디스패치 : 준비상태에서 대기하고 있는 프로세스 중 하나가 CPU를 할당받아 실행상태로 변하는 시점)
      - 비동기적 행위를 일으키는 주체
        (비동기적행위 : 다중프로그래밍 방식에서 CPU가 하나의 프로그램만을 연속적으로 처리하지 않고, 
                       여러 프로그램의 일부분을 반복적으로 실행하고 중단하는 행위
      - 프로시저가 활동 중인 상태

## 2. 프로세스의 상태
## 2.1 프로세스 상태 전이도
     
<img width="350" src="https://user-images.githubusercontent.com/29009929/153714239-64045644-0e00-45a5-b390-559b050d7a23.png">

    - 준비 : CPU를 사용하고 있지는 않지만 언제든지 사용할 수 있는 상태, CPU에 의해 처리되기 위해 주기억장치에 존재하는 상태
    - 실행 : 프로세스가 CPU를 차지하고 있는 상태, 프로세스의 명령이 실행되고 있는 상태
    - 대기 : 프로세스가 어떤 사건이 일어나기를 기다리고 있는 상태, 처리속도가 느린 입출력 작업중인 상태
    - 디스패치 : 준비상태에 있는 여러 프로세스 중, 한 프로세스를 선정하여 CPU를 할당하는 시점
    - I/O발생 : 프로세스가 CPU사용중에 I/O(입출력)행위가 필요하여 대기상태로 이동하는 시점
    - 깨움 : 입출력 작업이 완료되어 준비상태로 이동하는 시점
    - 프로세스의 모든 자원 이용 순서는 요청->사용->해제
    
---
# S2. 인터럽트 처리
## 1. 인터럽트 개념
## 1.1 인터럽트
      - 프로세스가 수행 중에 다른 프로세스 수행을 위해 현재 수행 중인 프로세스를 중단하거나,  
        외부입력장치에 의해 프로세스가 중단되는 현상
      - 현재 프로세스를 중단시키는 모든 행위
## 1.2 인터럽트 작업 순서
      1) 인터럽트 발생 시, 운영체제가 제어권 받음
      2) 운영체제는 인터럽트 받은 현재의 프로세스 상태를 저장
      3) 운영체제는 인터럽트 정보를 분석하여 지정되어있는 루틴으로 제어권을 넘겨줌
      4) 인터럽트 처리 루틴이 인터럽트 처리
      5) 인터럽트가 걸렸던 이전의 프로세스 상태로 복구
      6) 인터럽트가 걸렸던 시점 이후부터 

## 3. 문맥교환
     - 다중프로그래밍 시스템에서 CPU가 할당되는 프로세스를 변경하기 위하여, 현재 CPU를 사용하여 실행되고 있는
       프로세서의 상태 정보를 저장하고, 제어권을 인터럽트 서비스 루틴에게 넘기는 작업
     - 프로세스의 중단과 실행 시 인터럽트가 발생하므로, 문맥교환이 많이 일어난다는 것은 인터럽트가 많이 발생한다는 것

---
# S3. 중앙처리장치(CPU)스케줄링 (=프로세스스케줄링)
## 1. 프로세스스케줄링 성능평가 기준 (CPU이용률/처리능력/대기시간/응답시간/반환시간)
      1) 처리능력(Throughput) : 단위시간당 처리할 수 있는 CPU의 작업량
      2) 대기시간(Waiting Time) : 준비상태에서 대기하는 시간
      3) 응답시간(Response Time, 반응시간) : 입력에 대해 처음 반응하는 시간
      4) 반환시간(Turn-around Time) : 작업을 지시하고, 그 결과가 되돌아오는 시간
## 1.1 큐(Queue)
- 한쪽에서 삽입하고, 다른 한쪽에서는 삭제하는 메모리 사용방식으로, 선입선출(FIFO)방식으로 접근되는 대기 리스트
- 선형 큐 : 앞부분과 끝부분이 연결되어있지 않은 큐, 주로 직선형태
- 환형 큐 : 앞부분과 끝부분이 연결되어 있어 원 형태로 사용하는 큐

## 2. 프로세스스케줄링 알고리즘
## 2.1 비선점형방식과 선점형방식의 비교
### 비선점(Non Preemptive)
      - 프로세스가 CPU에 할당되면, 권한을 빼앗을 수 없음
      - 일괄처리방식에 적당
      - 대화형, 시분할, 실시간 시스템에 부적당
      - FIFO, SJF, HRN, 우선순위, 기한부 방식
      - 문맥교환이 적어 오버헤드(실행을위한부가적노력)가 적음
### 선점(Preemptive)
      - 프로세스가 CPU에 할당되면, 우선순위가 높으면 빼앗을 수 있음
      - 일괄처리방식에 부적당
      - 대화형, 시분할, 실시간 시스템에 적당
      - RR(라운드로빈), SRT, MFQ 방식
      - 문맥교환이 많아 오버헤드가 

## 3. 비선점형방식
## 3.1 FIFO 
- 먼저 입력된 작업을 먼처 처리하는 방식으로 가장 간단함
- 공평하고 구현이 간단하나, 평균반환시간이 길다
- 짧은 작업이나 중요한 작업을 오랫동안 기다리게 할 수 있음
- 평균반환시간 = 평균실행시간+평균대기시간
- 제출시간이 있는 경우, 대기시간 계산시 제출시간을 빼고 계산하면됨 (p193)

## 3.2 SJF (Shortest Job First, 최단작업우선)
- **실행시간 추정치가 가장 작은 작업(최단작업)을 먼저 실행**시키는 방식
- 짧은 작업들을 우선 처리하기 때문에, 대기리스트 안에 있는 작업의 수를 최소화시키면서, 평균반환시간 최소화 가능
- 긴 작업일지라도 이미 CPU를 점유하고 있다면 뒤로 밀려나지 않고 처리되며, 다음작업들을 대상으로 재정리를 함
- 긴 작업인 경우, 계속되서 입력되는 짧은 작업들 때문에 우선순위가 계속 밀려나게 되고, **무한연기상태가 발생하기도 함**
- FIFO를 개선한 방식
- 무한연기현상을 방지하기 위해 **에이징기법 사용**
- 제출시간이 있는 경우, 제출시간이 가장 빠른 작업을 우선대기리스트에 배치한 후, 나머지 작업들을 짧은작업 순서대로 배치함
- 가장 처음 제추로딘 작업의 실행시간이 길더라도, 짧은 작업이 뺏을 수 없음
- 시분할시스템에 적용 어려움

## 3.2.1 에이징기법(Aging)
- SJF의 무한연기현상을 방지하기 위한 기법
- 오랜 시간 기다린 프로세스는, 기다린 시간에 비례하는 높은 우선순위를 부여하여 가까운 시간안에 자원이 할당되도록 하는 기법

## 3.3 HRN (Highest Response-ratio Next)
- 서비스시간과 대기시간의 비율을 고려한 스케줄링 방법
- SJF에서 발생 가능한 무한연기현상을 극복하기 위해 개발됨
- 우선순위 계산 공식 이용
- 우선순위 = (대기시간+서비스시간)/서비스시간
- 계산값이 가장 큰 작업에게 우선권 부여

## 3.4 우선순위스케줄링
- 대기리스트에 있는 프로세스들에게 작업의 우선순위를 부여하여 CPU를 할당하는 방법
- SJF스케줄링도 작업량이 적은 작업에 우선순위를 부여했으므로, 우선순위 스케줄링의 한 예라고 볼 수 있음
- 고정적우선순위와 동적우선순위방식이 있으며, 동적우선순위는 구현이 어렵고 오버헤드가 크다
- 기아현상 또는 무한봉쇄현상이 발생 가능
### 3.4.1 기아현상(Starvation, =아사현상, 무한봉쇄현상)
- 우선순위가 낮은 작업은 영원히 처리되지 않는 현상
- 에이징기법을 통해 해결 가능
## 3.5 기한부스케줄링
- 제한된 시간내에 반드시 작업이 완료되도록 스케줄링하는 방식
- 작업이 완료되는 제한된 시간을 정확히 추정하여 그 시간만큼에 CPU 사용시간을 제한함.
- 작업이 제한 시간내에 처리되지 않으면, 다시는 해당작업이 CPU 사용시간을 할당받을 수 없는 방시
- 동시에 다수의 기한부 작업 수행시 스케줄링은 어려워지고, 막대한 오버헤드 발생 가능

## 4. 선점형방식
## 4.1 라운드로빈 (RR)
- 시분할 시스템을 위해 고안된 방식
- 시간할당량(Time Slice, Quantum)이라는 작은 단위시간이 정의되어, 시간할당량만큼씩 CPU를 사용하는 방법
- 비선점의 FIFO방식을 선점형으로 변환한 방식
- 먼저 입력된 작업이라도 할당된 시간만 CPU 이용 가능
- 할당시간내에 작업을 완료하지 못할 경우, CPU는 다음 대기중인 프로세스에게로 사용권한이 넘어가고
- 현재 실행중이던 프로세스는 대기리스트의 가장 뒤로 배치됨
- 시간할당량이 적을 경우, 문맥교환에 따른 오버헤드가 커지므로 적절한 시간 배정이 중요
- 시간할당량이 크면 비선점의 FIFO와 거의 같은 형태가 됨
## 4.2 SRT (Shortest Remaining Time)
- 작업이 끝나기까지 **남아있는 실행시간의 추정치가 가장 작은 프로세스 먼저** 실행
- 비선점의 SJF와 달리, 남아있는 프로세스의 실행 추정치가 더 작은 프로세스가 있다면, 
- 언제든지 현재 작업중인 프로세스를 중단하여 더 작은 프로세스에게 CPU를 넘겨줌
- 서비스받은 시간을 기록해야하고, 실행시간을 추적해야하므로 오버헤드가 늘어남
- 평균대기시간과 대기시간의분산(편차의제곱)도 크다
- 임계치를 사용함

## 4.3 다단계피드백큐(MFQ, Multi level Feedback Queue)
- 짧은 작업이나, 입출력위주의 작업에 우선권을 위해 개발된 방식
- 큐(대기리스트)가 여러개이며, 우선순위가 있음 (맨 위에 있는 큐가 가장 우선순위가 높고 시간할당량이 적음)
- 큐마다 시간할당량이 존재하며, 낮은 큐(아래에있는 큐)일수록 시간할당량은 커짐
- 각각의 큐들은 종속적으로 연결됨
- 각 큐는 자신보다 낮은 단계의 큐들에게서 절대적인 우선순위를 가짐
- 만약 B대기리스트가 CPU를 사용중일때, 그보다 위 리스트인 A에 프로세스가 입력되면, 
- B는 바로 중단하고 A대기리스트에 있는 프로세스에게 CPU사용권한을 넘겨줘야함
- CPU를 시간할당량만큼 사용한 프로세스는 낮은 큐로 이동됨 (ex. A대기리스트에서 처리후 남은 작업은 B대기리스트로)
- 맨 마지막 큐는 라운드로빈(RR) 방식으로 처리
- 결국, 짧은 작업이나 CPU를 적게 사용하는 입출력작업들은 최상위 큐에서 빨리 처리하게 되는 방식

<img width="250" src="https://user-images.githubusercontent.com/29009929/153744646-f72fcb9f-c524-4159-a5f3-d48ddab96398.png">

## 4.4 다단계큐(MQ, Multi level Queue)
- 대기리스트를 특성별로 여러개를 가짐
- 대기리스트에 우선순위 있음 (맨위가 우선순위 가장 높)
- 각 큐는 자신보다 낮은 단계의 큐들에게서 절대적인 우선순위를 가짐
- 대기리스트마다 독립적인 스케줄링을 가짐
- 대기리스트간에 프로세스 이동 불가능
- 우선순위가 가장 높은 큐에서는 비선점형 방식으로 사용 (우선순위가 가장 높은 큐의 프로세스는 절대 뺏을 수 없음)
- 나머지 큐에서는 선점형이므로 뺏기 가능
- 선점과 비선점을 결합한 스케줄링

<img width="250" src="https://user-images.githubusercontent.com/29009929/153744672-e1e1273a-1134-4cbb-a43d-cc2fe5896f29.png">


