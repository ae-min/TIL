# S1. 소프트웨어 검사
## 1. 소프트웨어 검사 관련 용어
- 검증(Verification) : 개발된 소프트웨어와 사용자의 요구분석 명세서와의 차이를 확인
- 검토회의(Walk-through) : 소프트웨어 생명주기 단계마다 산출된 명세서를 가지고 다음단계로 넘어가기 전에 오류를 찾아내는 작업
- 정형기술검토(FTR) : 소프트웨어에 관련된 여러 사람이 모여 회의하는 정형화된 오류검토회의

## 2. 화이트박스테스트
- 모듈안의 작동을 직접 관찰. 코드 보기 가능
- 논리적 구조를 체계적으로 점검하는 구조
- 원시코드의 모든 문장을 한번이상 수행함으로써 진행되는 검사
- 제품의 내부요소들이 명세서에 따라 수행되고, 충분히 실행되었는가를 보장하기위한 검사
- 프로그램의 제어구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적인 경로를 검사

## 2.1 화이트박스테스트의 종류
### 1. 기초경로검사(Basic Path Testing, 구조검사)
    - 프로그램 전체의 내부구조나 모듈내부의 구조를 대상으로 검사하는 방법
    - 검사대상의 모든 논리적인 경로를 복잡도로 계산하여 구한 후, 경로를 수행할 수 있는 검사 경우를 직접 입력하여 오류를 찾음
    - 분명하게 검사는 가능하지만, 시간이 많이 걸리는 단점이 있음
    
    [기초경로검사 순서]
    1) 원시프로그램을 보고 흐름도표 작성 (순차, 선택, 반복, 다중선택 등)
    2) 복잡도계산 
       - 복잡도 : 흐름도표의 영역의 수, 검사하고자 하는 루틴이 수행되는 모든 경로
       - 6~10개 이하가 가장 적당하며, 그 이상이 될 경우 중복 루틴을 모듈화하여 그 복잡도를 감소시켜야함
       - 복잡도 계산공식은 '오일러공식'과 '인접행렬이용' 두가지 방법이 있음
       
       * 오일러공식 = 노드(원,정점)수 - 간선(화살표)수 + 면(영역)수
                     복잡도는 면(영역)수와 같으므로, 
                     복잡도R = 간선수E - 노드수V + 2
                     (면의 수는 그래프 밖의 면 한개를 포함함)
       * 인접행렬 : 화살표가 한번에 갈 수 있으면 1, 없으면 0으로 인접행렬 표현
                   - 각 행마다 1의 요소를 더한 후 1을 차감
                   - 이러한 각 행의 값을 구한 후 모두 더한 뒤, 추가로 1을 더해주면 복잡도가 계산됨
    3) 검사 경우 결정 : 복잡도 개수만큼의 검사경우를 정하여 오류 판단
    4) 판단 : 오류가 있으면 수정 후 재검사
     
### 2. 루프검사(Loop Testing, 반복문검사)
    - 반복문의 반복횟수, 반복문의 초기값, 인덱스 변수, 최종 비교값의 오류 등을 찾는 검사

    [루프검사방법]
    1) 루프 전체를 건너뛰기
    2) 루프를 한번만 수행
    3) 루프를 두번 수행
    4) 루프를 M번 수행하되 N보다 작은 값을 입력하여 수행
    5) 루프를 N-1, N, N+1번 수행

### 3. 데이터흐름검사(Data Flow Testing)
### 4. 조건검사(Condition Testing)

## 3. 블랙박스테스트
- 모듈안의 내용을 직접 관찰 불가. 코드를 볼 수 없음
- 제품의 각 기능이 완전히 작동되는 것을 입증하는 검사
- 정확한 입력에 대한 출력의 정확성 검사

## 3.1 블랙박스테스트의 종류
### 1. 균등분할(Equivalence Partitioning, 동치분할, 동등분할)
- 검사사례 설계를 프로그램의 입력 명세조건에 따라 설정
- 프로그램의 입력조건에 중점을 두고, 
- 어느하나의 입력조건에 대하여 타당한 값과 타당하지않은 값을 설정

### 2. 한계값분석(Boundary Value Analysis)
- 범위의 한계부분을 집중적으로 검사
- 점수의 범위가 0부터 100점이라면, 한계가 되는 0점이나 100점에 인접한 자료를 집중적으로 검사

### 3. 원인-결과그래프(Cause-Effect Graphing)
- 임의의 자료가 입력될 때, 예측한 결과가 출력되지 않으면 오류로 판정하는 기법

### 4. 오류예측(Error Guessing)
- 균등분할, 한계점분석, 원인결과그래프에서 놓칠 수 있을 법한 오류데이터를 입력하여 검사하는 방법
- 데이터확인(Data Validation)방법이라고도 함
- ex)영문입력란에 한글입력, 동명이인 입력, 주민번호 오류입력 등

---
# S2. 소프트웨어 검사전략
## 1. 소프트웨어 검사순서
- **검사순서** : 단위->통합->검증->시스템테스트
- **개발순서** : 시스템공학->요구분석->설계->코딩(구현)
- 검사와 개발순서는 반대로 진행됨

## 2. 단위테스트(=코드테스트, 모듈테스트, 프로그램설계테스트)
- 원시프로그램의 모듈(함수, 프로시저, 클래스, 독립적인 루틴 등)을 대상으로 화이트박스 테스트를 실시하는 방법

      - 인터페이스검사 : 모듈간 매개변수 전달 시의 오류 및 파일 사용 시의 오류 검사
      - 자료구조검사 : 모듈 내 항목의 데이터타입, 레코드선언 등 오류 검사
      - 경로검사 : 기초경로검사 및 루프검사
      - 오류처리검사 : 비정상적인 자료 입력 시 오류 메시지가 올바른지 검사
      - 한계값검사 : 입력범위에 인접한 값들을 입력하여 검사

## 3. 통합테스트(=Integration, 결합테스트, 구조설계테스트)
- 단위테스트 이후, 단위별(모듈별)로 결합하면서 오류를 찾는 방법
- 가장 오류가 많이 발견되는 검사이며, 프로그램만을 대상으로 검사
## 3.1 하향식통합테스트(Top Down)
- 상위모듈에서 하위모듈로 결합하면서 오류를 찾는 방법
- 가짜모듈인 스텁(Stub)이 필요함
- 프로그램 전체를 실행하면서 검사가능
- 독립적인 구조로 검사가능 (외부프로그램인 드라이버 필요없이, 자체 프로그램만으로 검사 가능)
- 중요한 모듈을 우선 검사해야할 때에는 적당하지 않음

      [하향식통합테스트 순서]
      1) 전체프로그램을 매번 실행하고, 종속적인 하위모듈은 가짜모듈인 스텁(Stub)으로 대체
      2) 통합방법에 따라 가짜모듈을 실제모듈로 대치
      3) 각 모듈이 통합되면 검사 실시
      4) 통합될때마다 회귀검사 실시

      *회귀테스트(Regression Testing) : 프로그램이나 코드 변경이 기존 기능에 나쁜 영향을 미치지 않았음을 확인

## 3.2 상향식통합테스트(Bottom Up)
- 최하위 모듈부터 상위로 진행하면서 통합하는 방식
- 스텁은 필요없지만, 통합시에 통합된 클러스터를 실행할 수 있는 드라이버(Driver)가 필요
- 프로그램 전체를 실행하면서 검사할 수 없음
- 독립적인 구조로 검사 불가능 (외부프로그램인 드라이버가 필요함)
- 중요한 모듈을 우선 검사해야할 때 유리함 
 
      [상향식통합테스트 순서]
      1) 낮은 수준의 모듈들을 클러스터로 결합
         (클러스터 : 여러개의 모듈을 하나로 묶어 놓은 단위)
      2) 드라이버(Driver)라는 제어프로그램을 개발
      3) 클러스터 검사
      4) 드라이버를 제거하고, 클러스터를 상위로 결합
      5) 최종 드라이버를 제거하고, 전체적인 소프트웨어 구조로 완성

## 4. 검증테스트(Validation Test)
- 사용자의 요구명세서에 있는 내적, 외적인 요구를 실제 구현된 프로그램과 비교하면서 검사하는 기법
  
      [검증테스트 종류]
      - 외부테스트 : 요구분석서에 정의된 외부명세(입출력화면, 파일 등 프로그램 외적요인)대로 수행되는가를 비교하면서 검사
      - 내부테스트 : 요구분석서에 정의된 내부명세(처리조건, 계산방법 등 내부요인)대로 수행되는가를 비교하면서 검사
      - 알파테스트 : 사용자를 제한된 환경으로 초대하여 프로그램을 수행하게 하고,
                    개발자는 사용자가 프로그램을 수행하는 모습을 지켜보며 오류를 찾는 검사
      - 베타테스트 : 다수의 사용자를 제한되지 않은 환경에서 프로그램을 수행하게 하고, 
                    오류가 발견되면 개발자에게 통보하는 방식의 검사

## 5. 시스템테스트
- H/W, S/w, DB와 같은 요소들과 적절하게 결합되어 운용되는지, 전체시스템의 기능이나 성능에 문제가 없는지 확인하는 검사
    
      [시스템테스트 종류]
      - 확인테스트(검토회의Walk-through) : 개발된 소프트웨어에 이해관계가 있는 모든 사람이 참석하여 오류를 찾는 방법
      - 보안테스트 
      - 무결성테스트 
      - 스트레스테스트 : 소프트웨어에 다양한 형태의 스트레스를 주어 검사하는 방법
                        짧은 시간에 많은 양의 데이터를 입력해보거나, 많은 양의 문서를 출력하는 등 비정상적인 사용을
                        함으로써 프로그램의 반응을 검사
      - 부피테스트 : 소프트웨어가 처리할 수 있는 한계치를 입력하여 검사하는 방법(최소,최대)
      - 메모리테스트 : 주기억장치나 보조기억장치의 활용도 검사
      - 성능테스트 : 소프트웨어의 실시간 성능 검사
      - 호환성테스트 : 소프트웨어 수정 시, 기존에 사용하던 파일 및 소프트웨어와의 호환성 검사
      - 신뢰성테스트 : 복잡한 계산이나 오류에 대처할 수 있는 능력 검사
      - 회복테스트 : 다양한 방법으로 오류가 발생하도록 한 뒤, 회복이 적절히 수행되는지 테스트
      - 사용용이성테스트 : 초보자도 쉽게 이용가능한지 테스트
      - 유지보수용이성테스트

## 6. 정형기술검토(FTR : Formal Technical Review, 정형화된 검토회의)
- 정형화 : 일정한 형식이나 틀을 갖추게 됨
## 6.1 정형기술검토 목적
- 소프트웨어가 요구사항과 일치되는 정도 확인
- 소프트웨어의 표준화 여부 검토
- 정형화된 소프트웨어가 개발되도록 지원
- 프로젝트 관리
## 6.2 정형기술검토 제약사항
- 참가자 수 제한 (보통 3~5명 참여)
- 사전준비 필요
- 각 개인에게 2시간 이상을 요구해서는 안됨
- 검토모임시간은 2시간 이내로 제한
- 의견을 제한하되, 충분히 받아들이기
- 논쟁과 반박제한







