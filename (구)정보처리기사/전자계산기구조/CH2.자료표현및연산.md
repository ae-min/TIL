# S1. 자료표현의 기본
## 1. 자료의 단위
- 비트 - 니블 - 바이트 - 워드 - 필드 - 레코드 - 블록 - 파일 - 데이터베이스
1) 비트 : 0,1의 표현으로 **전자계산기 구조의 최소단위**
2) 니블 : 4개의 비트를 하나로 묶은 단위. 보통 16진수 표현 단위로 사용됨
3) 바이트 : 8개의 비트를 하나로 묶은 단위. 문자 표현의 단위로 사용됨
4) 워드 : 내부 표현이나 처리를 위해 사용되는 단위 (half : 2byte, full : 4byte, double : 8byte)
5) 필드 : 어떤 특성이나 속성 표현을 위한 단위로, **최소의 논리적 단위**
6) 레코드 : 워드가 모여서 이루는 논리적 단위로, **정보가 처리되는 단위**
7) 블록 : 입출력을 위해 논리 레코드를 묶어 놓은 단위로, **물리적 레코드**라고 함
8) 파일 : 괸련있는 종류의 레코드를 묶어 나타낸 단위, **저장 장치에 사용되는 단위**
9) 데이터베이스 : 서로 관련이 있는 단위를 통합하여 묶어 놓은 데이터 그룹

## 2. 자료의 외부표현
## 2.1 표준 BCD 코드
- 존(ZONE) 2비트, 디지트(DIGIT) 4비트의 총 6비트로 하나의 문자를 나타냄
- 최대 64문자까지 표현 가능. 초창기에 사용하던 코드
- 영문자, 소문자는 약속되어있지 않음
 <img width="600" src="https://user-images.githubusercontent.com/29009929/152633707-52e6b803-698e-46f0-ab14-1166475407d6.png">
 <img width="600" src="https://user-images.githubusercontent.com/29009929/152633803-cb33c5de-26e6-479d-a643-af172fb54a5c.png">

## 2.2 EBCDIC 코드
- BCD코드의 존비트를 4비트로 확장하여, 최대 256문자까지 표현할 수 있도록 한 확장된 BCD코드
- 존 4비트와 디지트 4비트의 총 8비트로 구성
- IBM사에서 개발한 것으로 대형컴퓨터에 쓰임
<img width="400" src="https://user-images.githubusercontent.com/29009929/152633813-346cbdca-dc36-4191-a1a3-9eb7b2266ecf.png">

## 2.3 ASCII 코드
- 7비트로 한 문자를 표현할 수 있어서 총 128문자까지 표현 가능하며, 1비트의 패리티비트를 합쳐 총 8비트로 사용됨
- 미국 표준 협회가 제안하여 채택된 코드
- 데이터통신용으로 널리 쓰이며, 특히 개인용 및 소형 컴퓨터용으로 쓰임
- 제어부호 33개, 그래픽기호 33개, 숫자 10개, 알파벳 대·소문자 52개로 구성됨
- 000-001 데이터전송에 쓰이는 제어문자, 010 그래픽기호, 011 숫자, 100-101 알파벳대문자, 110-111 알파벳소문자
<img width="300" src="https://user-images.githubusercontent.com/29009929/152633912-337031f3-35e1-455c-8263-98359f2f4d01.png">

# S4. 코드의 표현
## 1. 3초과 코드
- 비가중치코드이며 자기보수코드
- 8421코드를 3초과시켜 만든 코드(8421코드에 3을 더해서 만듬)
## 2. 그레이코드 
- 각 자리에 일정 값을 부여하는 가중치 값이 없느 비가중치 코드
- 한 비트의 변화만으로 다음 값을 만들 수 있기 때문에 변화가 적음
- 기계적인 동작 제어에 알맞은 코드, 입출력 장치의 동작이나 아날로그 신호를 디지털 신호로 변환하는데 사용 가능
- 2진코드->그레이코드 변환(오른쪽에서아래로), 그레이코드->2진코드변환 (아래에서다음위로)
## 3. 해밍코드
- 에러체크 뿐만아니라 수정까지 가능한 코드
- 홀/짝패리티가 문제로 지정되지 않은 경우 기본적으로는 짝수패리티로 계산하는 듯
## 4. 패리티비트 
- 1의개수가 홀수개가 되는지 짝수개가 되는지 체크하기 위해 추가하는 비트
- 1비트 오류검출이 가능
- 해밍코드에 이용됨
- <패리티비트 공식>: 2<sup>p</sup> >= p+n+1
- p : 패리티비트 추가 개수, n : 데이터비트개수
- ex) 1110의 경우, 2<sup>3</sup> >= 3+4+1 이므로, 패리티비트 개수는 3개(2<sup>0</sup>,2<sup>1</sup>,2<sup>2</sup>)
- 2<sup>0</sup> : 1,3,5,7
- 2<sup>1</sup> : 2,3,6,7
- 2<sup>2</sup> : 4,5,6,7
- 홀수패리티면 1이 홀수개가 되도록, 짝수패리티면 1이 짝수개가 되도록
