# 자료구조

### 연결리스트

- 데이터를 저장할 공간이 필요할 때마다 동적으로 공간을 만들어서 쉽게 추가 가능
- 순차적 표현 방법인 배열에 비해 상당한 장점
- 하지만, 배열에 비해 구현이 어렵고, 오류가 발생하기 쉬움
- 하나의 프로그램 안에는 동시에 여러 개의 연결리스트가 존재 가능
- 이때 연결리스트를 구별하는 것은 맨 첫 번째 데이터
- 노드들의 저장 위치 순서가 리스트상의 순서와 동일하지 않을 수 있음
- 링크필드를 위한 추가 공간이 필요하다는 단점을 지님

### 연결리스트 구조

- 데이터필드 및 링크필드로 구성
- 데이터필드 : 저장하고 싶은 데이터가 들어감
- 링크필드 : 다른 노드를 가리키는 포인터 저장
- 헤드포인터 : 연결리스트마다 첫 번째 노드를 가리키고 있는 변수
- 마지막 노드의 링크필드는 NULL로 설정

### 연결리스트 종류

1. **단순연결리스트(singly linked list)**
- 하나의 방향으로만 연결
1. **원형연결리스트(circular linked list)**
- 단순연결리스트와 같으나, 마지막 노드의 링크 값이 첫번째 노드를 가리킴
- 리스트 끝에 노드를 삽입하는 연산이 단순연결리스트보다 효율적
1. **이중연결리스트(doubly linked list)**
- 각 노드마다 링크필드가 2개씩 존재
- 앞에있는 노드와 다음에 있는 노드를 가리키는 링크를 모두 가짐
- 양방향 검색이 가능하다는 장점이 있지만, 공간을 많이 차지하고 코드가 복잡하다는 단점을 지님
- 왼쪽링크필드-데이터필드-오른쪽링크필드로 구성

---

### 스택

- 가장 최근에 들어온 상자가 가장 먼저 출력되는 후입선출(LIFO)구조
- 배열 및 연결리스트로 구현 가능

### 스택의 용도

- 출력순서가 입력순서의 역순으로 이루어져야 하는 경우(ex.되돌리기undo)
- 함수호출에서 복귀주소를 기억하는데 사용

### 배열로 구현한 스택

- int타입의 1차원배열 stack[max_stack_size]이 필요
- 가장 먼저 들어온 요소는 stack[0]에, 가장 최근에 들어온 요소는 stack[top]에 저장됨
- top변수는 스택에 아무런 데이터가 없으면(공백) -1의 값을 가짐

### 연결리스트로 구현한 스택

- 동적메모리 할당이 가능하므로 크기가 제한되지 않는다는 장점을 가짐
- 대신, 동적메모리 할당이나 해제를 해야하므로 삽입이나 삭제시간은 조금 더 소요되고 비쌈

---

### 큐

- 먼저 들어간 데이터가 먼저 나가는 구조인 선입선출(FIFO)구조(ex.매표소)
- 스택과 달리 삽입과 삭제가 다른 쪽에서 발생
- 삽입이 일어나는 곳 : 후단(rear)
- 삭제가 일어나는 곳 : 전단(front)

### 배열로 구현한 큐 (선형 큐)

- front는 큐의 첫번째 요소(첫번째로 삭제할 요소)를 가리킴
- rear는 큐의 마지막 요소(마지막으로 삽입된 요소)를 가리킴
- front와 rear의 초기값은 -1이며, 데이터가 증가되면 rear(후단)를 하나 증가
- 데이터가 삭제되면 front(전단)를 하나 증가
- front와 rear의 값이 계속 증가만 하기 때문에 언젠가는 배열의 끝에 도달하게 되고, 배열의 앞부분이 비어있더라도 사용하지 못한다는 단점이 있음

### 배열로 구현한 큐 (원형 큐)

- 처음과 끝이 연결되어 있다고 생각
- front와 rear의 초기값은 -1이 아닌 0
- front는 항상 큐의 첫번째 요소의 하나 앞을 가리킴
- rear는 마지막 요소를 가리킴
- 원형큐는 포화상태와 공백상태를 구별하기 위해서 하나의 자리를 항상 비워둠
- front와 rear의 값이 같으면 원형큐가 비어있음(공백)을 나타냄
- front가 rear보다 하나 앞에 있으면 포화상태

### 연결리스트로 구현한 큐

- 단순연결리스트에다가 2개의 포인터를 추가한 것과 같음
- 큐에 요소가 없는 경우에는 front와 rear는 NULL값이 됨
- 큐의 요소들은 구조체로 정의됨
- 구조체는 데이터를 저장하는 item필드와, 다음노드를 가리키기 위한 link필드로 이루어짐

---

### 데크

- 큐의 전단과 후단에서 모두 삽입과 삭제가 가능한 큐
- 스택과 큐의 연산들을 모두 가지고 있음
- 보통 이중연결리스트로 구현
- 이중연결리스트의 첫번째노드와 마지막노드를 가리키는 포인터를 동시에 가지고 있어야 함
- 따라서, 데크와 관련된 변수는 첫번째노드를 가리키는 변수인 head와 마지막노드를 가리키는 tail이 됨

---

### 이진트리

- 모든 노드가 2개의 서브트리를 가지고 있는 트리
- 서브트리는 공집합일 수 있음 (노드를 하나도 가지지 않을 수 있음)
- 최대 2개까지의 자식노드가 존재할 수 있고, 모든 노드이 차수는 2 이하가 됨
- 서브트리 간에 순서가 존재하므로, 왼쪽서브트리와 오른쪽서브트리는 서로 구별됨

### 이진트리의 성질

- N개의 노드를 가진 이진트리는 N-1개의 간선을 가짐
- 높이가 H인 노드의 경우, 최소 H개의 노드를 가지며 최대 2의 H제곱-1개의 노드를 가짐
- 한 레벨에는 적어도 하나의 노드는 존재해야 하므로 높이가 H인 이진트리는 적어도 H개의 노드를 가짐
- N개의 노드를 가지는 이진트리의 높이는, 최소 log2(N+1)이거나 최대 N
- 레벨당 최소한 하나의 노드는 있어야 하므로 높이가 최대 N개를 넘을 수 없음

### 이진트리의 분류

1. **포화이진트리(full binary tree)**
- 각 레벨에 노드가 꽉 차있는 이진트리
- 높이가 K인 포화이진트리는 정확하게 2의K제곱-1개의 노드를 가짐
- 레벨단위로 왼쪽에서 오른쪽으로 번호를 붙이면 됨
2. **완전이진트리(complete binary tree)**
- 높이가 k일때 레벨1부터 k-1까지는 노드가 모두 채워져있고, 마지막 레벨 k에서는 왼쪽부터 오른쪽으로 노드가 순서대로 채워져있는 이진트리
- 마지막 레벨에서는 노드가 꽉차있지 않아도 되지만, 중간에 빈 곳이 있어서는 안됨
- 따라서, 포화이진트리는 완전이진트리이지만, 완전이진트리는 포화이진트리는 항상 성립되지 않음

### 이진트리 순회

- 전위 Pre : VLR
- 중위 In : LVR
- 후위 Post : LRV

---

### 이진탐색트리

- binary search tree
- 이진탐색트리의 성질을 만족하는 이진트리
- 모든 노드의 키는 유일해야함
- 왼쪽서브트리의 키들은 루트의 키보다 작음
- 오른쪽서브트리의 키들은 루트의 키보다 큼
- 왼쪽과 오른쪽서브트리도 이진탐색트리

### 이진탐색트리에서 삽입연산

- 원소 삽입을 위해서는 먼저 탐색을 수행하는 것이 필요함
- 모든 노드의 키는 유일해야하므로, 같은 키 값을 갖는 노드가 없어야 하기 때문
- 또한, 탐색에 실패한 위치가 새로운 노드를 삽입하는 위치가 되기 때문
- ex) 9를 삽입하는 경우, 만약 탐색이 성공하면 이미 9가 트리안에 있는 것이고, 탐색키가 중복되는 것이므로 삽입이 불가능
- 만약, 트리안에 9가 없다면 못찾아서 탐색이 실패할 것이므로, 그 실패한 위치가 9가 있을 위치

### 이진탐색트리 시간복잡도

- (높이가 h일때) 탐색 / 삽입 / 삭제의 시간복잡도 : **O(h)**
- n개의 노드를 가지는 이진탐색트리의 경우, **균형잡힌 이진트리**의 높이는 log2n이므로, 이진탐색트리 연산의 평균 시간복잡도는 **O(log2n)**
- **한쪽으로 치우친 경사이진트리**의 경우, 탐색 / 삽입 / 삭제 시간복잡도 : **O(n)**

---

### 우선순위 큐

- 데이터들이 우선순위를 가지고있고, 우선순위가 높은 데이터가 먼저 나가게 됨
- 배열, 연결리스트 등 구현이 가능하며, 가장 효율적인 구조는 히프(heap)

### 우선순위 큐 시간복잡도

1. **배열을 사용하는 방법 (정렬이 안된 경우)**
- 삽입 : 그냥 요소들의 맨 끝에 붙이면 되므로, **O(1)**
- 삭제 : 가장 우선순위가 높은 요소를 삭제하는 경우, 처음부터 끝까지 모든 요소를 스캔해야 하므로 **O(n)**
2. **배열을 사용하는 방법 (정렬이 된 경우)**
- 삽입 : 삽입위치를 찾은 후에는, 삽입 위치 뒤에 있는 요소들을 이동시켜 빈자리를 만든 다음 삽입해야하므로 **O(n)**
- 삭제 : 숫자가 높은 것이 우선순위가 높다고 가정하면 맨 뒤 요소만 삭제하면 되므로 **O(1)**
3. **연결리스트를 사용하는 방법**
- 삽입 : 포인터만 변경하면 되므로 **O(1)**
- 삭제 : 포인터를 따라서 모든 노드를 탐색해야하므로, **O(n)**
4. **히프를 사용하는 방법 (히프는 일종의 반정렬상태)**
- 삽입 / 삭제 모두 **O(log2n)**

---

### 히프

- 여러개의 값들 중에서 가장 큰 값이나, 가장 작은 값을 빠르게 찾아내도록 만들어진 자료구조
- 부모노드의 키 값이 자식노드의 키 값보다 항상 크거나, 항상 작은 이진트리
- 삽입 시 마지막노드에 삽입된 값이 항상크거나, 항상 작아야 하는 조건을 만족할 수 있도록 자리를 계속 교환해줘야 함
- 삭제연산은 최댓값을 가진 루트노드를 삭제하는 것이므로, 루트 삭제 후 맨마지막 인덱스를 가진 노드를 루트로 올림, 그리고 그 루트도 조건에 맞도록 자리를 계속 교환해줘야 함
- 이진탐색트리는 모든 노드의  키가 유일해야하지만, 히프는 중복된 값 허용함
- 히프 안에서 데이터들은 느슨한 정렬 상태를 유지함
- 히프는 완전이진트리이므로, 왼쪽부터 차례대로 번호를 부여 가능
- 히프를 저장하는 표준적인 자료구조는 배열
- 부모노드의 키 값 > 자식노드의 키 값 : 최대히프
- 부모노드의 키 값 < 자식노드의 키 값 : 최소히프
- 왼쪽자식의 인덱스 : 부모인덱스*2
- 오른쪽자식의 인덱스 : 부모인덱스*2+1
- 부모의 인덱스 : 자식인덱스
- 삽입 / 삭제 시간복잡도 : **O(log2n)**

---

### 허프만코드

- 데이터빈도수에 따라 우선순위 큐에서 작은노드 2개를 꺼내고, 이를 합쳐 트리를 만드는 것
- 루트의 값은 각 자식노드의 값을 합한 값
- 각 글자의 빈도가 알려져 있는 메시지내용을 압축하는데 사용될 수 있음
- 이런, 특별한 이진트리를 허프만코딩트리라고 함
- 가장 많이 등장하는 글자에는 짧은비트열사용, 가장 적게 등장하는 글자에는 긴 비트열 사용
- 비트열을 왼쪽에서 오른쪽으로 조사
- 둘중 낮은 빈도수는 왼쪽, 높은 빈도수는 오른쪽에 위치
- 왼쪽간선은 비트 1, 오른쪽간선은 비트 0
- 단순히 루트노드에서 단말노드까지의 경로에 있는 간선 라벨 값을 읽으면 됨
