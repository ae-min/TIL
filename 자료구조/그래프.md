# 그래프

### 오일러경로

- 그래프에 존재하는 모든 간선을 한번만 통과하면서, 처음 정점으로 되돌아오는 경로

### 오일러정리

- 그래프의 모든 정점에 연결된 간선의 개수가 짝수일 때만 오일러경로가 존재함

### 그래프 구성

- 정점(노드)과 간선(링크)
- 그래프는 오직 정점과 간선의 집합일 뿐이며, 시각적인 형태가 그래프의 정의는 아님

---

### 그래프의 종류

---

### 무방향그래프

- 간선을 통해서 양방향 이동 가능
- (A,B)
- (A,B)와 (B,A)는 동일한 간선

### 방향그래프

- 간선에 방향성이 존재
- <A,B>
- <A,B>와 <B,A>는 서로 다른 간선

### 가중치그래프(=네트워크)

- 간선에 비용이나 가중치가 할당된 그래프

### 부분그래프

- 정점의 집합과 간선의 집한의 부분집합으로 이루어진 그래프
- 일부 정점이나 간선을 제외하여 만들어진 그래프

### 연결그래프

- 무방향그래프에 있는 모든 정점 쌍에 대하여 항상 경로가 존재한다면, 그래프는 연결되어 있다고 하며, 이러한 무방향그래프를 연결그래프라고 함
- 그렇지 않은 그래프 : 비연결그래프
- 트리는 그래프의 특수한 형태로서, 모두 연결되어 경로가 존재하지만 사이클을 가지지 않는 연결그래프

### 완전그래프

- 그래프에 속해있는 모든 정점이 서로 연결되어 있는 그래프
- 정점의 수를 N이라고 하면, 간선의 수는 N * (N-1) / 2

---

### 그래프의 표현방법

---

### 인접행렬

- 그래프에 간선이 많이 존재하는 밀집그래프를 표현하는 경우에 적합
- 적은 숫자의 간선을 가지는 희소그래프를 인접행렬로 표현할 경우 메모리의 낭비가 심함
- 두 정점을 연결하는 간선의 존재여부 확인 : O(1)
- 정점의 차수 : O(n)
- 모든 간선의 수 : O(n2)

### 인접리스트

- 간선의 개수가 적은 희소그래프에 적합
- 각 연결리스트의 노드들은 인접 정점을 저장
- n개의 정점과 e개의 간선을 가진 그래프의 전체 간선 수 : O(n+e)

---

### 그래프의 탐색

---

### 깊이우선탐색 (Depth, DFS)

- 미로 탐색 시 한 방향으로 갈 수 있을 때 까지 가보다가, 더 이상 갈 수 없게되면 다시 가장 가까운 갈림길로 돌아와서, 이곳으로부터 다른 방향으로 다시 탐색을 진행하는 방법과 유사
- 그래프의 시작 정점에서 출발하여 먼저 시작 정점 V를 방문하고 방문했다고 표시
- V에 인접한 정점들 중에서 아직 방문하지 않은 정점 u를 선택
- 만약, 미방문한 정점 u가 있다면, u를 시작 정점으로 해서 다시 깊이우선탐색
- 그러나, u가 없다면 탐색 종료
- 자기 자신을 다시 호출하는 순환알고리즘의 형태를 가짐
- 모든 간선을 조사하므로, 정점의 수가 n이고 간선의 수가 e인 그래프를 깊이우선탐색하는 경우, 인접리스트로 표현 시 O(n+e), 인접행렬로 표현 시 O(n2)

### 깊이우선탐색의 구현

- 순환호출방법
- 명시적 스택을 사용하여, 방문한 정점들을 스택에 저장했다가 다시 꺼내기

### 너비우선탐색 (Breadth, BFS)

- 시작정점으로부터 가까운 정점을 먼저 방문하고, 멀리 떨어져 있는 정점을 나중에 방문
- 정점이 방문될 때마다 큐에 방문된 정점을 삽입하고, 더 이상 방문할 인접정점이 없는 경우, 큐의 앞에서 정점을 꺼내어 그 정점과 인접한 정점들을 모두 차례대로 방문
- 초기상태의 큐에는 시작정점만이 저장되고, 너비우선탐색과정은 큐가 소진될때까지 계속됨
- 정점의 수가 n이고 간선의 수가 e인 그래프를 너비우선탐색하는 경우, 인접리스트로 표현 시 O(n+e), 인접행렬로 표현 시 O(n2) →깊이우선탐색과 동일

### 너비우선탐색의 구현

- 큐 사용 ( 방문한 정점을 차례대로 저장한 후 꺼내기 위해서, 선입선출)

---

### 신장트리 (spanning tree)

- 그래프 내의 모든 정점을 포함하는 트리
- 모든 정점들이 연결되어 있어야 하고, 사이클을 허용해서는 안됨
- 그래프에 있는 n개의 정점을 정확히 n-1개의 간선으로 연결 (이럴 경우 필연적으로 트리형태가 되며 이것이 바로 신장트리)
- 그래프에서 신장트리를 찾으려면, 깊이우선탐색 또는 너비우선탐색 사용 가능
- 간선의 수가 가장 적은, 최소연결부분그래프
- 한개의 그래프에는 많은 신장트리 존재 가능
- 통신네트워크 구축에 사용됨

---

### 최소비용신장트리(MST : minimum spanning tree) p425

- 네트워크에 있는 모든 정점들을 가장 적은 수의 간선과 비용으로 연결
- 가중치의 합이 최소인 신장트리
- Kruskal 크루스칼과 Prim프림이 제안한 알고리즘이 대표적이며,
- 이 알고리즘들은 최소비용신장트리가 간선의 가중치합이 최소이어야 하고, 반드시 (n-1)개의 간선만 사용해야하며, 사이클이 포함되어서는 안된다는 조건들을 적절히 이용하고 있음

---

### 최소비용신장트리 알고리즘

---

### Kruskal의 MST알고리즘

- 탐욕적인방법(Greedy그리디)을 이용 : 그순간에 가장 좋다고 생각되는 것을 선택
- MST가 최소비용의 간선으로 구성됨과 동시에 사이클을 포함하지 않는다는 조건에 근거하여, 각 단계에서 사이클을 이루지 않는 최소비용간선을 선택
- **간선e개를 퀵정렬과 같은 효율적인 알고리즘으로 정렬 시 시간복잡도 : O(elog2e) →희박한 그래프에 유리함**
- 간선 선택을 기반으로 하는 알고리즘 (이전단계에서 만들어진 신장트리와는 상관없이 무조건 최소 가중치를 지닌 간선만을 선택하는 방법
1. 먼저, 그래프의 e개의 간선들을 가중치의 오름차순으로 정렬
2. 정렬된 간선리스트에서 순서대로 사이클을 형성하지 않는 간선들 중 가장 가중치가 낮은 간선부터 먼저 선택하여 현재의 최소비용신장트리의 집합에 추가
3. 만약, 사이클을 형성하면 그 간선은 제외시킴

### union-find 연산

- Kruskal의 MST알고리즘에서, 간선의 양끝 정점이 서로 다른 집합에 속하는 경우 두 정점을 연결하여도 사이클이 형성되지 않음.
- 따라서, 현재 추가하고자 하는 간선의 양끝 정점이 같은 집함에 속해있는지를 먼저 검사해야함.
- 이 검사를 위한 알고리즘이 union-find 알고리즘
- Kruskal알고리즘에서만 사용되는 것은 아니고, 일반적으로 널리 사용됨
- **union(x,y)연산은 원소 x와 y가 속해있는 집합을 입력으로 받아, 2개의 집합의 합집합을 만듬**
- **find(x,y)연산은 원소 x가 속해있는 집합을 반환**

---

### Prim의 MST알고리즘

- 시작정점에서부터 출발하여 신장트리집합을 단계적으로 확장해나가는 방법
- 시작단계에서는 시작정점만이 신장트리집합에 포함됨
- 앞 단계에서 만들어진 시작정점만이 담긴 신장트리집합에, 인접한 정점들 중에서 최소간선으로 연결된 정점을 선택하여 트리를 확장하며, 트리가 n-1개의 간선을 가질 때까지 계속됨
- 정점 선택을 기반으로 하는 알고리즘
- 이전단계에서 만들어진 신장트리를 확장하는 방식
- **Prim의 알고리즘 시간복잡도 : O(n2) →밀접한 그래프에 유리함**

---

### 최단경로알고리즘

---

### 다익스트라의 최단경로알고리즘

- 하나의 시작정점으로부터 모든 다른정점까지의 최단경로를 찾는 알고리즘
- 집합 S : 시작정점v로부터 최단경로가 이미 발견된 정점들의 집합이라고 가정
- 집합 S에 있지 않은 정점 중에서 가장 distance값이 작은 정점을 s에 추가하고, 그 다음엔 추가된 정점을 기준으로 distance값을 수정하고 비교해나가며 거리가 더 짧은 경로를 찾아나가는 방식
- **두개의 정점사이의 최단경로를 찾는** **다익스트라 시간복잡도 : O(n2)**
- **모든 접점 쌍의 초단경로를 찾는 다익스트라 시간복잡도 : O(n3)**

### Floyd의 최단경로알고리즘

- 그래프에 존재하는 모든정점사이의 최단경로를 한번에 모두 찾아주는 알고리즘
- 두 개의 정점 사이에 간선이 존재하면 가중치를 표시하고,
- 존재하지 않으면 무한대(인피니트) 표시
- **Floyd 시간복잡도 : 3중반복문을 사용하므로 O(n3)**
- 다익스트라와 비슷하지만, Floyd는 더 간결한 반복구조이므로 다익스트라보다 더 빨리 최단경로를 찾을 수 있음

---

### 위상정렬(topological sort)

- 방향그래프에서 <u,v>가 있을 경우, 정점 u는 정점v를 선행한다고 말함
- 방향그래프에 존재하는 각 정점들의 선행순서를 위배하지 않으면서 모든 정점을 나열하는 것을 방향그래프의 위상이라고 함
1. 먼저 진입차수가 0인 정점(그 정점으로 들어오는게 아무것도 없는 정점)을 선택하고, 선택된 정점과 여기에 부속된 모든 간선을 삭제 (선택되는 순서대로 정렬되는 것이며, 그 순서를 위상순서라고 함)
2. 이와같이 진입차수가 0인 정점의 선택과 삭제 과정을 반복해서 모든 정점이 선택 및 삭제되면 알고리즘이 종료됨
3. 진입차수가 0인 정점이 여러개 존재할 경우 어느 정점을 선택해도 무방함
